
BFU1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fe6  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000012  00800060  00000fe6  0000109a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000008c  00800072  00800072  000010ac  2**0
                  ALLOC
  3 .eeprom       0000000e  00810000  00810000  000010ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .debug_aranges 00000020  00000000  00000000  000010ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000002d9  00000000  00000000  000010da  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000544  00000000  00000000  000013b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000105  00000000  00000000  000018f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000006bd  00000000  00000000  000019fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000080  00000000  00000000  000020bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000026d  00000000  00000000  0000213c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	14 c0       	rjmp	.+40     	; 0x2a <__ctors_end>
   2:	2e c0       	rjmp	.+92     	; 0x60 <__bad_interrupt>
   4:	2d c0       	rjmp	.+90     	; 0x60 <__bad_interrupt>
   6:	2c c0       	rjmp	.+88     	; 0x60 <__bad_interrupt>
   8:	2b c0       	rjmp	.+86     	; 0x60 <__bad_interrupt>
   a:	d3 c5       	rjmp	.+2982   	; 0xbb2 <__vector_5>
   c:	29 c0       	rjmp	.+82     	; 0x60 <__bad_interrupt>
   e:	28 c0       	rjmp	.+80     	; 0x60 <__bad_interrupt>
  10:	54 c6       	rjmp	.+3240   	; 0xcba <__vector_8>
  12:	26 c0       	rjmp	.+76     	; 0x60 <__bad_interrupt>
  14:	25 c0       	rjmp	.+74     	; 0x60 <__bad_interrupt>
  16:	24 c0       	rjmp	.+72     	; 0x60 <__bad_interrupt>
  18:	23 c0       	rjmp	.+70     	; 0x60 <__bad_interrupt>
  1a:	22 c0       	rjmp	.+68     	; 0x60 <__bad_interrupt>
  1c:	eb c6       	rjmp	.+3542   	; 0xdf4 <__vector_14>
  1e:	20 c0       	rjmp	.+64     	; 0x60 <__bad_interrupt>
  20:	1f c0       	rjmp	.+62     	; 0x60 <__bad_interrupt>
  22:	1e c0       	rjmp	.+60     	; 0x60 <__bad_interrupt>
  24:	1d c0       	rjmp	.+58     	; 0x60 <__bad_interrupt>
  26:	1c c0       	rjmp	.+56     	; 0x60 <__bad_interrupt>
  28:	1b c0       	rjmp	.+54     	; 0x60 <__bad_interrupt>

0000002a <__ctors_end>:
  2a:	11 24       	eor	r1, r1
  2c:	1f be       	out	0x3f, r1	; 63
  2e:	cf e5       	ldi	r28, 0x5F	; 95
  30:	d2 e0       	ldi	r29, 0x02	; 2
  32:	de bf       	out	0x3e, r29	; 62
  34:	cd bf       	out	0x3d, r28	; 61

00000036 <__do_copy_data>:
  36:	10 e0       	ldi	r17, 0x00	; 0
  38:	a0 e6       	ldi	r26, 0x60	; 96
  3a:	b0 e0       	ldi	r27, 0x00	; 0
  3c:	e6 ee       	ldi	r30, 0xE6	; 230
  3e:	ff e0       	ldi	r31, 0x0F	; 15
  40:	02 c0       	rjmp	.+4      	; 0x46 <.do_copy_data_start>

00000042 <.do_copy_data_loop>:
  42:	05 90       	lpm	r0, Z+
  44:	0d 92       	st	X+, r0

00000046 <.do_copy_data_start>:
  46:	a2 37       	cpi	r26, 0x72	; 114
  48:	b1 07       	cpc	r27, r17
  4a:	d9 f7       	brne	.-10     	; 0x42 <.do_copy_data_loop>

0000004c <__do_clear_bss>:
  4c:	10 e0       	ldi	r17, 0x00	; 0
  4e:	a2 e7       	ldi	r26, 0x72	; 114
  50:	b0 e0       	ldi	r27, 0x00	; 0
  52:	01 c0       	rjmp	.+2      	; 0x56 <.do_clear_bss_start>

00000054 <.do_clear_bss_loop>:
  54:	1d 92       	st	X+, r1

00000056 <.do_clear_bss_start>:
  56:	ae 3f       	cpi	r26, 0xFE	; 254
  58:	b1 07       	cpc	r27, r17
  5a:	e1 f7       	brne	.-8      	; 0x54 <.do_clear_bss_loop>
  5c:	02 d0       	rcall	.+4      	; 0x62 <main>
  5e:	c1 c7       	rjmp	.+3970   	; 0xfe2 <_exit>

00000060 <__bad_interrupt>:
  60:	cf cf       	rjmp	.-98     	; 0x0 <__vectors>

00000062 <main>:
#include "main.h"
/*==========================================================================================================================*/
/*                                                  Главная функция программы                                               */
/*==========================================================================================================================*/
int main(void)
{
  62:	0f 93       	push	r16
  64:	1f 93       	push	r17
  66:	df 93       	push	r29
  68:	cf 93       	push	r28
  6a:	00 d0       	rcall	.+0      	; 0x6c <main+0xa>
  6c:	00 d0       	rcall	.+0      	; 0x6e <main+0xc>
  6e:	00 d0       	rcall	.+0      	; 0x70 <main+0xe>
  70:	cd b7       	in	r28, 0x3d	; 61
  72:	de b7       	in	r29, 0x3e	; 62
  DDRA  = 0;           //ALL inputs
  74:	ea e3       	ldi	r30, 0x3A	; 58
  76:	f0 e0       	ldi	r31, 0x00	; 0
  78:	10 82       	st	Z, r1
  PORTA = 0;
  7a:	eb e3       	ldi	r30, 0x3B	; 59
  7c:	f0 e0       	ldi	r31, 0x00	; 0
  7e:	10 82       	st	Z, r1

  DDRB  = 0xe3;        //SAVE, TOGGLE и MODE - входы
  80:	e7 e3       	ldi	r30, 0x37	; 55
  82:	f0 e0       	ldi	r31, 0x00	; 0
  84:	83 ee       	ldi	r24, 0xE3	; 227
  86:	80 83       	st	Z, r24
  PORTB = 0xff;
  88:	e8 e3       	ldi	r30, 0x38	; 56
  8a:	f0 e0       	ldi	r31, 0x00	; 0
  8c:	8f ef       	ldi	r24, 0xFF	; 255
  8e:	80 83       	st	Z, r24

  DDRC  = 0xff;
  90:	e4 e3       	ldi	r30, 0x34	; 52
  92:	f0 e0       	ldi	r31, 0x00	; 0
  94:	8f ef       	ldi	r24, 0xFF	; 255
  96:	80 83       	st	Z, r24
  PORTC = 0xff;
  98:	e5 e3       	ldi	r30, 0x35	; 53
  9a:	f0 e0       	ldi	r31, 0x00	; 0
  9c:	8f ef       	ldi	r24, 0xFF	; 255
  9e:	80 83       	st	Z, r24

  DDRD  = 0xbf;        //PD6 - Input
  a0:	e1 e3       	ldi	r30, 0x31	; 49
  a2:	f0 e0       	ldi	r31, 0x00	; 0
  a4:	8f eb       	ldi	r24, 0xBF	; 191
  a6:	80 83       	st	Z, r24
  PORTD = 0xff;        //transmit=off
  a8:	e2 e3       	ldi	r30, 0x32	; 50
  aa:	f0 e0       	ldi	r31, 0x00	; 0
  ac:	8f ef       	ldi	r24, 0xFF	; 255
  ae:	80 83       	st	Z, r24

  _WDR();
  b0:	a8 95       	wdr

  InitAd();
  b2:	86 d4       	rcall	.+2316   	; 0x9c0 <InitAd>
  ADCSRA |= (1<<ADIE); //enable AD interrupt
  b4:	a6 e2       	ldi	r26, 0x26	; 38
  b6:	b0 e0       	ldi	r27, 0x00	; 0
  b8:	e6 e2       	ldi	r30, 0x26	; 38
  ba:	f0 e0       	ldi	r31, 0x00	; 0
  bc:	80 81       	ld	r24, Z
  be:	88 60       	ori	r24, 0x08	; 8
  c0:	8c 93       	st	X, r24
  sei();               //enable global interrupt
  c2:	78 94       	sei
 
  SPCR = 0;            //disable SPI
  c4:	ed e2       	ldi	r30, 0x2D	; 45
  c6:	f0 e0       	ldi	r31, 0x00	; 0
  c8:	10 82       	st	Z, r1
  SPSR = 0;            
  ca:	ee e2       	ldi	r30, 0x2E	; 46
  cc:	f0 e0       	ldi	r31, 0x00	; 0
  ce:	10 82       	st	Z, r1

  TIMSK = TIMSK|0x20;  //разрешение прерывания по событию «Захват» таймера/счетчика T1
  d0:	a9 e5       	ldi	r26, 0x59	; 89
  d2:	b0 e0       	ldi	r27, 0x00	; 0
  d4:	e9 e5       	ldi	r30, 0x59	; 89
  d6:	f0 e0       	ldi	r31, 0x00	; 0
  d8:	80 81       	ld	r24, Z
  da:	80 62       	ori	r24, 0x20	; 32
  dc:	8c 93       	st	X, r24
  TCCR1B = 0xc1;       //ICNC1 = 1 схема подавления помех включена и захват осуществляется только в случае 4-х одинаковых выборок, соответствующих активному фронту сигнала
  de:	ee e4       	ldi	r30, 0x4E	; 78
  e0:	f0 e0       	ldi	r31, 0x00	; 0
  e2:	81 ec       	ldi	r24, 0xC1	; 193
  e4:	80 83       	st	Z, r24
                       //ICES1 = 1 cохранение счетного регистра в регистре захвата осуществляется по нарастающему фронту сигнала
                       //CS10  = 1 нет предделения тактовой частоты контроллера для тактирования Т1, 0.0625мкс
  TIMSK = TIMSK|0x4;   //разрешение прерывания по переполнению таймера/счетчика T1
  e6:	a9 e5       	ldi	r26, 0x59	; 89
  e8:	b0 e0       	ldi	r27, 0x00	; 0
  ea:	e9 e5       	ldi	r30, 0x59	; 89
  ec:	f0 e0       	ldi	r31, 0x00	; 0
  ee:	80 81       	ld	r24, Z
  f0:	84 60       	ori	r24, 0x04	; 4
  f2:	8c 93       	st	X, r24

  Dt4_8 = Dt4_30 = Dt4_37 = Dt5_37 = Dt5_95 = Dt5_118 = Dt6_115 = Dd1_1 = Dd1_4 = Nd_500 = Nd_1450 = Nd_1750 = 0;
  f4:	10 92 85 00 	sts	0x0085, r1
  f8:	80 91 85 00 	lds	r24, 0x0085
  fc:	80 93 bb 00 	sts	0x00BB, r24
 100:	80 91 bb 00 	lds	r24, 0x00BB
 104:	80 93 fd 00 	sts	0x00FD, r24
 108:	80 91 fd 00 	lds	r24, 0x00FD
 10c:	80 93 89 00 	sts	0x0089, r24
 110:	80 91 89 00 	lds	r24, 0x0089
 114:	80 93 7d 00 	sts	0x007D, r24
 118:	80 91 7d 00 	lds	r24, 0x007D
 11c:	80 93 76 00 	sts	0x0076, r24
 120:	80 91 76 00 	lds	r24, 0x0076
 124:	80 93 d6 00 	sts	0x00D6, r24
 128:	80 91 d6 00 	lds	r24, 0x00D6
 12c:	80 93 b1 00 	sts	0x00B1, r24
 130:	80 91 b1 00 	lds	r24, 0x00B1
 134:	80 93 b4 00 	sts	0x00B4, r24
 138:	80 91 b4 00 	lds	r24, 0x00B4
 13c:	80 93 81 00 	sts	0x0081, r24
 140:	80 91 81 00 	lds	r24, 0x0081
 144:	80 93 8b 00 	sts	0x008B, r24
 148:	80 91 8b 00 	lds	r24, 0x008B
 14c:	80 93 d5 00 	sts	0x00D5, r24
  array[9] = 0;
 150:	10 92 d7 00 	sts	0x00D7, r1
 154:	10 92 d6 00 	sts	0x00D6, r1
  from_ee[9] = 0;
 158:	10 92 ea 00 	sts	0x00EA, r1
 15c:	10 92 e9 00 	sts	0x00E9, r1

  NDiz=0;
 160:	10 92 b8 00 	sts	0x00B8, r1
 164:	10 92 b7 00 	sts	0x00B7, r1
  CtTDiz=15;
 168:	8f e0       	ldi	r24, 0x0F	; 15
 16a:	80 93 84 00 	sts	0x0084, r24
  InvCounter=0;
 16e:	10 92 7e 00 	sts	0x007E, r1
  RegWait=30000;       //старое значение - 300 //Вернуть!!
 172:	80 e3       	ldi	r24, 0x30	; 48
 174:	95 e7       	ldi	r25, 0x75	; 117
 176:	90 93 b0 00 	sts	0x00B0, r25
 17a:	80 93 af 00 	sts	0x00AF, r24
 17e:	01 c0       	rjmp	.+2      	; 0x182 <main+0x120>
  while (RegWait--)

  _WDR();
 180:	a8 95       	wdr

  NDiz=0;
  CtTDiz=15;
  InvCounter=0;
  RegWait=30000;       //старое значение - 300 //Вернуть!!
  while (RegWait--)
 182:	20 91 af 00 	lds	r18, 0x00AF
 186:	30 91 b0 00 	lds	r19, 0x00B0
 18a:	3e 83       	std	Y+6, r19	; 0x06
 18c:	2d 83       	std	Y+5, r18	; 0x05
 18e:	1c 82       	std	Y+4, r1	; 0x04
 190:	8d 81       	ldd	r24, Y+5	; 0x05
 192:	9e 81       	ldd	r25, Y+6	; 0x06
 194:	00 97       	sbiw	r24, 0x00	; 0
 196:	11 f0       	breq	.+4      	; 0x19c <main+0x13a>
 198:	91 e0       	ldi	r25, 0x01	; 1
 19a:	9c 83       	std	Y+4, r25	; 0x04
 19c:	8d 81       	ldd	r24, Y+5	; 0x05
 19e:	9e 81       	ldd	r25, Y+6	; 0x06
 1a0:	01 97       	sbiw	r24, 0x01	; 1
 1a2:	90 93 b0 00 	sts	0x00B0, r25
 1a6:	80 93 af 00 	sts	0x00AF, r24
 1aa:	2c 81       	ldd	r18, Y+4	; 0x04
 1ac:	22 23       	and	r18, r18
 1ae:	41 f7       	brne	.-48     	; 0x180 <main+0x11e>

  _WDR();

  mask_leds_c = 0x00;                    //PORT C.X
 1b0:	10 92 b5 00 	sts	0x00B5, r1
  mask_leds_d = 0x00;                    //PORT D.X
 1b4:	10 92 74 00 	sts	0x0074, r1
  
  if (PINB & (1<<MODE))   mode = 1;      //выбор режима работы
 1b8:	e6 e3       	ldi	r30, 0x36	; 54
 1ba:	f0 e0       	ldi	r31, 0x00	; 0
 1bc:	80 81       	ld	r24, Z
 1be:	88 2f       	mov	r24, r24
 1c0:	90 e0       	ldi	r25, 0x00	; 0
 1c2:	80 71       	andi	r24, 0x10	; 16
 1c4:	90 70       	andi	r25, 0x00	; 0
 1c6:	00 97       	sbiw	r24, 0x00	; 0
 1c8:	21 f0       	breq	.+8      	; 0x1d2 <main+0x170>
 1ca:	81 e0       	ldi	r24, 0x01	; 1
 1cc:	80 93 ad 00 	sts	0x00AD, r24
 1d0:	02 c0       	rjmp	.+4      	; 0x1d6 <main+0x174>
  else                    mode = 0;
 1d2:	10 92 ad 00 	sts	0x00AD, r1

  if(!mode)                              //работа в режиме калибровки
 1d6:	80 91 ad 00 	lds	r24, 0x00AD
 1da:	88 23       	and	r24, r24
 1dc:	09 f0       	breq	.+2      	; 0x1e0 <main+0x17e>
 1de:	54 c1       	rjmp	.+680    	; 0x488 <__stack+0x229>
  {
    //инициализация переменных функции калибровки:
    Key_Inp = KEY_EMPTY;                 //кнопка не нажата
 1e0:	10 92 8a 00 	sts	0x008A, r1
    timer_250 = RELOAD;                  //начало нового цикла индикации длительностью 250 мс
 1e4:	8e e3       	ldi	r24, 0x3E	; 62
 1e6:	80 93 ba 00 	sts	0x00BA, r24
    count_channel = 0;                   //счёт начинается с 0-го канала
 1ea:	10 92 bd 00 	sts	0x00BD, r1
    const_write_ok = 0;                  //записи констант не было
 1ee:	10 92 79 00 	sts	0x0079, r1
    mask_leds_c = 0x00;                  //PORT C.X
 1f2:	10 92 b5 00 	sts	0x00B5, r1
    mask_leds_d = 0x20;                  //PORT D.5
 1f6:	80 e2       	ldi	r24, 0x20	; 32
 1f8:	80 93 74 00 	sts	0x0074, r24

    while (1)
    {
     _WDR();
 1fc:	a8 95       	wdr

	 AccountADC();
 1fe:	b2 d4       	rcall	.+2404   	; 0xb64 <AccountADC>

	 //Dt4=444; Dt5=555; Dt6=666; Key_Inp = KEY_BS;

     //алгоритм записи и проверки записи калибровочных констант в EEPROM
     if(Key_Inp == KEY_BS)                                                     //если нажата кнопка "сохранить константу"            
 200:	80 91 8a 00 	lds	r24, 0x008A
 204:	88 30       	cpi	r24, 0x08	; 8
 206:	09 f0       	breq	.+2      	; 0x20a <main+0x1a8>
 208:	60 c0       	rjmp	.+192    	; 0x2ca <__stack+0x6b>
     {
	   eeprom_busy_wait();
 20a:	ec e3       	ldi	r30, 0x3C	; 60
 20c:	f0 e0       	ldi	r31, 0x00	; 0
 20e:	80 81       	ld	r24, Z
 210:	88 2f       	mov	r24, r24
 212:	90 e0       	ldi	r25, 0x00	; 0
 214:	82 70       	andi	r24, 0x02	; 2
 216:	90 70       	andi	r25, 0x00	; 0
 218:	00 97       	sbiw	r24, 0x00	; 0
 21a:	b9 f7       	brne	.-18     	; 0x20a <main+0x1a8>
       eeprom_update_word(ADDRESS_TO_EE, array[count_channel]);                //записать калибровочную константу, если значение другое
 21c:	80 91 bd 00 	lds	r24, 0x00BD
 220:	88 2f       	mov	r24, r24
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	88 0f       	add	r24, r24
 226:	99 1f       	adc	r25, r25
 228:	81 50       	subi	r24, 0x01	; 1
 22a:	9f 4f       	sbci	r25, 0xFF	; 255
 22c:	ac 01       	movw	r20, r24
 22e:	80 91 bd 00 	lds	r24, 0x00BD
 232:	88 2f       	mov	r24, r24
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	88 0f       	add	r24, r24
 238:	99 1f       	adc	r25, r25
 23a:	fc 01       	movw	r30, r24
 23c:	ec 53       	subi	r30, 0x3C	; 60
 23e:	ff 4f       	sbci	r31, 0xFF	; 255
 240:	20 81       	ld	r18, Z
 242:	31 81       	ldd	r19, Z+1	; 0x01
 244:	ca 01       	movw	r24, r20
 246:	b9 01       	movw	r22, r18
 248:	a7 d6       	rcall	.+3406   	; 0xf98 <__eeupd_word_m8535>
	   eeprom_busy_wait();
 24a:	ec e3       	ldi	r30, 0x3C	; 60
 24c:	f0 e0       	ldi	r31, 0x00	; 0
 24e:	80 81       	ld	r24, Z
 250:	88 2f       	mov	r24, r24
 252:	90 e0       	ldi	r25, 0x00	; 0
 254:	82 70       	andi	r24, 0x02	; 2
 256:	90 70       	andi	r25, 0x00	; 0
 258:	00 97       	sbiw	r24, 0x00	; 0
 25a:	b9 f7       	brne	.-18     	; 0x24a <main+0x1e8>
       from_ee[count_channel] = eeprom_read_word(ADDRESS_TO_EE);               //считать записанное значение для проверки
 25c:	80 91 bd 00 	lds	r24, 0x00BD
 260:	08 2f       	mov	r16, r24
 262:	10 e0       	ldi	r17, 0x00	; 0
 264:	80 91 bd 00 	lds	r24, 0x00BD
 268:	88 2f       	mov	r24, r24
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	88 0f       	add	r24, r24
 26e:	99 1f       	adc	r25, r25
 270:	81 50       	subi	r24, 0x01	; 1
 272:	9f 4f       	sbci	r25, 0xFF	; 255
 274:	8c d6       	rcall	.+3352   	; 0xf8e <__eerd_word_m8535>
 276:	9c 01       	movw	r18, r24
 278:	c8 01       	movw	r24, r16
 27a:	88 0f       	add	r24, r24
 27c:	99 1f       	adc	r25, r25
 27e:	fc 01       	movw	r30, r24
 280:	e9 52       	subi	r30, 0x29	; 41
 282:	ff 4f       	sbci	r31, 0xFF	; 255
 284:	31 83       	std	Z+1, r19	; 0x01
 286:	20 83       	st	Z, r18

       //проверка успешной записи
	   if(from_ee[count_channel] == array[count_channel]) const_write_ok = 1;  //поднять флаг об успешной записи константы
 288:	80 91 bd 00 	lds	r24, 0x00BD
 28c:	88 2f       	mov	r24, r24
 28e:	90 e0       	ldi	r25, 0x00	; 0
 290:	88 0f       	add	r24, r24
 292:	99 1f       	adc	r25, r25
 294:	fc 01       	movw	r30, r24
 296:	e9 52       	subi	r30, 0x29	; 41
 298:	ff 4f       	sbci	r31, 0xFF	; 255
 29a:	20 81       	ld	r18, Z
 29c:	31 81       	ldd	r19, Z+1	; 0x01
 29e:	80 91 bd 00 	lds	r24, 0x00BD
 2a2:	88 2f       	mov	r24, r24
 2a4:	90 e0       	ldi	r25, 0x00	; 0
 2a6:	88 0f       	add	r24, r24
 2a8:	99 1f       	adc	r25, r25
 2aa:	fc 01       	movw	r30, r24
 2ac:	ec 53       	subi	r30, 0x3C	; 60
 2ae:	ff 4f       	sbci	r31, 0xFF	; 255
 2b0:	80 81       	ld	r24, Z
 2b2:	91 81       	ldd	r25, Z+1	; 0x01
 2b4:	28 17       	cp	r18, r24
 2b6:	39 07       	cpc	r19, r25
 2b8:	21 f4       	brne	.+8      	; 0x2c2 <__stack+0x63>
 2ba:	81 e0       	ldi	r24, 0x01	; 1
 2bc:	80 93 79 00 	sts	0x0079, r24
 2c0:	02 c0       	rjmp	.+4      	; 0x2c6 <__stack+0x67>
       else                                               const_write_ok = 0;
 2c2:	10 92 79 00 	sts	0x0079, r1

       Key_Inp=KEY_EMPTY;                                          //установить флаг кнопка не нажата
 2c6:	10 92 8a 00 	sts	0x008A, r1
     }

     //алгоритм переключения индикации и записи калибровочных констант датчиков в ОЗУ
     if((Key_Inp == KEY_BT) || const_write_ok)  //если нажата кнопка "переключения канала" или была записана константа
 2ca:	80 91 8a 00 	lds	r24, 0x008A
 2ce:	84 30       	cpi	r24, 0x04	; 4
 2d0:	29 f0       	breq	.+10     	; 0x2dc <__stack+0x7d>
 2d2:	80 91 79 00 	lds	r24, 0x0079
 2d6:	88 23       	and	r24, r24
 2d8:	09 f4       	brne	.+2      	; 0x2dc <__stack+0x7d>
 2da:	90 cf       	rjmp	.-224    	; 0x1fc <main+0x19a>
     {
       if(count_channel > 6) count_channel = 0; //если было переключение с 8-го канала, то переключить на 0-й канал
 2dc:	80 91 bd 00 	lds	r24, 0x00BD
 2e0:	87 30       	cpi	r24, 0x07	; 7
 2e2:	10 f0       	brcs	.+4      	; 0x2e8 <__stack+0x89>
 2e4:	10 92 bd 00 	sts	0x00BD, r1
       switch (count_channel)                   //варианты индикации и записи калибровочных констант в зависимости от канала
 2e8:	80 91 bd 00 	lds	r24, 0x00BD
 2ec:	28 2f       	mov	r18, r24
 2ee:	30 e0       	ldi	r19, 0x00	; 0
 2f0:	3b 83       	std	Y+3, r19	; 0x03
 2f2:	2a 83       	std	Y+2, r18	; 0x02
 2f4:	8a 81       	ldd	r24, Y+2	; 0x02
 2f6:	9b 81       	ldd	r25, Y+3	; 0x03
 2f8:	83 30       	cpi	r24, 0x03	; 3
 2fa:	91 05       	cpc	r25, r1
 2fc:	09 f4       	brne	.+2      	; 0x300 <__stack+0xa1>
 2fe:	67 c0       	rjmp	.+206    	; 0x3ce <__stack+0x16f>
 300:	2a 81       	ldd	r18, Y+2	; 0x02
 302:	3b 81       	ldd	r19, Y+3	; 0x03
 304:	24 30       	cpi	r18, 0x04	; 4
 306:	31 05       	cpc	r19, r1
 308:	84 f4       	brge	.+32     	; 0x32a <__stack+0xcb>
 30a:	8a 81       	ldd	r24, Y+2	; 0x02
 30c:	9b 81       	ldd	r25, Y+3	; 0x03
 30e:	81 30       	cpi	r24, 0x01	; 1
 310:	91 05       	cpc	r25, r1
 312:	99 f1       	breq	.+102    	; 0x37a <__stack+0x11b>
 314:	2a 81       	ldd	r18, Y+2	; 0x02
 316:	3b 81       	ldd	r19, Y+3	; 0x03
 318:	22 30       	cpi	r18, 0x02	; 2
 31a:	31 05       	cpc	r19, r1
 31c:	0c f0       	brlt	.+2      	; 0x320 <__stack+0xc1>
 31e:	42 c0       	rjmp	.+132    	; 0x3a4 <__stack+0x145>
 320:	8a 81       	ldd	r24, Y+2	; 0x02
 322:	9b 81       	ldd	r25, Y+3	; 0x03
 324:	00 97       	sbiw	r24, 0x00	; 0
 326:	a1 f0       	breq	.+40     	; 0x350 <__stack+0xf1>
 328:	a5 c0       	rjmp	.+330    	; 0x474 <__stack+0x215>
 32a:	2a 81       	ldd	r18, Y+2	; 0x02
 32c:	3b 81       	ldd	r19, Y+3	; 0x03
 32e:	25 30       	cpi	r18, 0x05	; 5
 330:	31 05       	cpc	r19, r1
 332:	09 f4       	brne	.+2      	; 0x336 <__stack+0xd7>
 334:	76 c0       	rjmp	.+236    	; 0x422 <__stack+0x1c3>
 336:	8a 81       	ldd	r24, Y+2	; 0x02
 338:	9b 81       	ldd	r25, Y+3	; 0x03
 33a:	85 30       	cpi	r24, 0x05	; 5
 33c:	91 05       	cpc	r25, r1
 33e:	0c f4       	brge	.+2      	; 0x342 <__stack+0xe3>
 340:	5b c0       	rjmp	.+182    	; 0x3f8 <__stack+0x199>
 342:	2a 81       	ldd	r18, Y+2	; 0x02
 344:	3b 81       	ldd	r19, Y+3	; 0x03
 346:	26 30       	cpi	r18, 0x06	; 6
 348:	31 05       	cpc	r19, r1
 34a:	09 f4       	brne	.+2      	; 0x34e <__stack+0xef>
 34c:	7f c0       	rjmp	.+254    	; 0x44c <__stack+0x1ed>
 34e:	92 c0       	rjmp	.+292    	; 0x474 <__stack+0x215>
       {
         case 0:                                    
           mask_leds_c = 0x00; //PORT C.X
 350:	10 92 b5 00 	sts	0x00B5, r1
           mask_leds_d = 0x20; //PORT D.5
 354:	80 e2       	ldi	r24, 0x20	; 32
 356:	80 93 74 00 	sts	0x0074, r24
		   array[count_channel] = Dt4;
 35a:	80 91 bd 00 	lds	r24, 0x00BD
 35e:	88 2f       	mov	r24, r24
 360:	90 e0       	ldi	r25, 0x00	; 0
 362:	20 91 d2 00 	lds	r18, 0x00D2
 366:	30 91 d3 00 	lds	r19, 0x00D3
 36a:	88 0f       	add	r24, r24
 36c:	99 1f       	adc	r25, r25
 36e:	fc 01       	movw	r30, r24
 370:	ec 53       	subi	r30, 0x3C	; 60
 372:	ff 4f       	sbci	r31, 0xFF	; 255
 374:	31 83       	std	Z+1, r19	; 0x01
 376:	20 83       	st	Z, r18
 378:	7d c0       	rjmp	.+250    	; 0x474 <__stack+0x215>
           break;
         case 1:
		   mask_leds_c = 0x00; //PORT C.X
 37a:	10 92 b5 00 	sts	0x00B5, r1
           mask_leds_d = 0x08; //PORT D.3
 37e:	88 e0       	ldi	r24, 0x08	; 8
 380:	80 93 74 00 	sts	0x0074, r24
		   array[count_channel] = Dt4;
 384:	80 91 bd 00 	lds	r24, 0x00BD
 388:	88 2f       	mov	r24, r24
 38a:	90 e0       	ldi	r25, 0x00	; 0
 38c:	20 91 d2 00 	lds	r18, 0x00D2
 390:	30 91 d3 00 	lds	r19, 0x00D3
 394:	88 0f       	add	r24, r24
 396:	99 1f       	adc	r25, r25
 398:	fc 01       	movw	r30, r24
 39a:	ec 53       	subi	r30, 0x3C	; 60
 39c:	ff 4f       	sbci	r31, 0xFF	; 255
 39e:	31 83       	std	Z+1, r19	; 0x01
 3a0:	20 83       	st	Z, r18
 3a2:	68 c0       	rjmp	.+208    	; 0x474 <__stack+0x215>
           break;
         case 2:
           mask_leds_c = 0x04; //PORT C.2
 3a4:	84 e0       	ldi	r24, 0x04	; 4
 3a6:	80 93 b5 00 	sts	0x00B5, r24
           mask_leds_d = 0x00; //PORT D.X
 3aa:	10 92 74 00 	sts	0x0074, r1
		   array[count_channel] = Dt4;
 3ae:	80 91 bd 00 	lds	r24, 0x00BD
 3b2:	88 2f       	mov	r24, r24
 3b4:	90 e0       	ldi	r25, 0x00	; 0
 3b6:	20 91 d2 00 	lds	r18, 0x00D2
 3ba:	30 91 d3 00 	lds	r19, 0x00D3
 3be:	88 0f       	add	r24, r24
 3c0:	99 1f       	adc	r25, r25
 3c2:	fc 01       	movw	r30, r24
 3c4:	ec 53       	subi	r30, 0x3C	; 60
 3c6:	ff 4f       	sbci	r31, 0xFF	; 255
 3c8:	31 83       	std	Z+1, r19	; 0x01
 3ca:	20 83       	st	Z, r18
 3cc:	53 c0       	rjmp	.+166    	; 0x474 <__stack+0x215>
           break;
         case 3:
           mask_leds_c = 0x10; //PORT C.4
 3ce:	80 e1       	ldi	r24, 0x10	; 16
 3d0:	80 93 b5 00 	sts	0x00B5, r24
           mask_leds_d = 0x00; //PORT D.X
 3d4:	10 92 74 00 	sts	0x0074, r1
		   array[count_channel] = Dt5;
 3d8:	80 91 bd 00 	lds	r24, 0x00BD
 3dc:	88 2f       	mov	r24, r24
 3de:	90 e0       	ldi	r25, 0x00	; 0
 3e0:	20 91 7b 00 	lds	r18, 0x007B
 3e4:	30 91 7c 00 	lds	r19, 0x007C
 3e8:	88 0f       	add	r24, r24
 3ea:	99 1f       	adc	r25, r25
 3ec:	fc 01       	movw	r30, r24
 3ee:	ec 53       	subi	r30, 0x3C	; 60
 3f0:	ff 4f       	sbci	r31, 0xFF	; 255
 3f2:	31 83       	std	Z+1, r19	; 0x01
 3f4:	20 83       	st	Z, r18
 3f6:	3e c0       	rjmp	.+124    	; 0x474 <__stack+0x215>
           break;
         case 4:
           mask_leds_c = 0x01; //PORT C.0
 3f8:	81 e0       	ldi	r24, 0x01	; 1
 3fa:	80 93 b5 00 	sts	0x00B5, r24
           mask_leds_d = 0x00; //PORT D.X
 3fe:	10 92 74 00 	sts	0x0074, r1
		   array[count_channel] = Dt5;
 402:	80 91 bd 00 	lds	r24, 0x00BD
 406:	88 2f       	mov	r24, r24
 408:	90 e0       	ldi	r25, 0x00	; 0
 40a:	20 91 7b 00 	lds	r18, 0x007B
 40e:	30 91 7c 00 	lds	r19, 0x007C
 412:	88 0f       	add	r24, r24
 414:	99 1f       	adc	r25, r25
 416:	fc 01       	movw	r30, r24
 418:	ec 53       	subi	r30, 0x3C	; 60
 41a:	ff 4f       	sbci	r31, 0xFF	; 255
 41c:	31 83       	std	Z+1, r19	; 0x01
 41e:	20 83       	st	Z, r18
 420:	29 c0       	rjmp	.+82     	; 0x474 <__stack+0x215>
           break;
         case 5:
           mask_leds_c = 0x08; //PORT C.3
 422:	88 e0       	ldi	r24, 0x08	; 8
 424:	80 93 b5 00 	sts	0x00B5, r24
           mask_leds_d = 0x00; //PORT D.X
 428:	10 92 74 00 	sts	0x0074, r1
		   array[count_channel] = Dt6;
 42c:	80 91 bd 00 	lds	r24, 0x00BD
 430:	88 2f       	mov	r24, r24
 432:	90 e0       	ldi	r25, 0x00	; 0
 434:	20 91 82 00 	lds	r18, 0x0082
 438:	30 91 83 00 	lds	r19, 0x0083
 43c:	88 0f       	add	r24, r24
 43e:	99 1f       	adc	r25, r25
 440:	fc 01       	movw	r30, r24
 442:	ec 53       	subi	r30, 0x3C	; 60
 444:	ff 4f       	sbci	r31, 0xFF	; 255
 446:	31 83       	std	Z+1, r19	; 0x01
 448:	20 83       	st	Z, r18
 44a:	14 c0       	rjmp	.+40     	; 0x474 <__stack+0x215>
           break;
         case 6:
           mask_leds_c = 0x02; //PORT C.1
 44c:	82 e0       	ldi	r24, 0x02	; 2
 44e:	80 93 b5 00 	sts	0x00B5, r24
           mask_leds_d = 0x00; //PORT D.X
 452:	10 92 74 00 	sts	0x0074, r1
		   array[count_channel] = Dt5;
 456:	80 91 bd 00 	lds	r24, 0x00BD
 45a:	88 2f       	mov	r24, r24
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	20 91 7b 00 	lds	r18, 0x007B
 462:	30 91 7c 00 	lds	r19, 0x007C
 466:	88 0f       	add	r24, r24
 468:	99 1f       	adc	r25, r25
 46a:	fc 01       	movw	r30, r24
 46c:	ec 53       	subi	r30, 0x3C	; 60
 46e:	ff 4f       	sbci	r31, 0xFF	; 255
 470:	31 83       	std	Z+1, r19	; 0x01
 472:	20 83       	st	Z, r18
           break;
        }
        count_channel++;       //переключение на следующий канал
 474:	80 91 bd 00 	lds	r24, 0x00BD
 478:	8f 5f       	subi	r24, 0xFF	; 255
 47a:	80 93 bd 00 	sts	0x00BD, r24
		const_write_ok = 0;    //сброс состояния записи
 47e:	10 92 79 00 	sts	0x0079, r1
        Key_Inp=KEY_EMPTY;     //кнопка не нажата
 482:	10 92 8a 00 	sts	0x008A, r1
 486:	ba ce       	rjmp	.-652    	; 0x1fc <main+0x19a>
          eeprom_busy_wait();
	      array[i] = eeprom_read_word(ADDRESS_FROM_EE);    //записать уставку из изменённой ячейки EEPROM в ОЗУ
        }
    }
*/
    for (i=0; i<9; i++) array[i] = ustavki[i];
 488:	19 82       	std	Y+1, r1	; 0x01
 48a:	18 c0       	rjmp	.+48     	; 0x4bc <__stack+0x25d>
 48c:	89 81       	ldd	r24, Y+1	; 0x01
 48e:	48 2f       	mov	r20, r24
 490:	50 e0       	ldi	r21, 0x00	; 0
 492:	89 81       	ldd	r24, Y+1	; 0x01
 494:	88 2f       	mov	r24, r24
 496:	90 e0       	ldi	r25, 0x00	; 0
 498:	88 0f       	add	r24, r24
 49a:	99 1f       	adc	r25, r25
 49c:	fc 01       	movw	r30, r24
 49e:	ec 59       	subi	r30, 0x9C	; 156
 4a0:	ff 4f       	sbci	r31, 0xFF	; 255
 4a2:	20 81       	ld	r18, Z
 4a4:	31 81       	ldd	r19, Z+1	; 0x01
 4a6:	ca 01       	movw	r24, r20
 4a8:	88 0f       	add	r24, r24
 4aa:	99 1f       	adc	r25, r25
 4ac:	fc 01       	movw	r30, r24
 4ae:	ec 53       	subi	r30, 0x3C	; 60
 4b0:	ff 4f       	sbci	r31, 0xFF	; 255
 4b2:	31 83       	std	Z+1, r19	; 0x01
 4b4:	20 83       	st	Z, r18
 4b6:	89 81       	ldd	r24, Y+1	; 0x01
 4b8:	8f 5f       	subi	r24, 0xFF	; 255
 4ba:	89 83       	std	Y+1, r24	; 0x01
 4bc:	89 81       	ldd	r24, Y+1	; 0x01
 4be:	89 30       	cpi	r24, 0x09	; 9
 4c0:	28 f3       	brcs	.-54     	; 0x48c <__stack+0x22d>

    /*Work program*/
    while (1)
    {
      _WDR();
 4c2:	a8 95       	wdr
      AccountADC();
 4c4:	4f d3       	rcall	.+1694   	; 0xb64 <AccountADC>
      AccountNDiz();
 4c6:	a4 d2       	rcall	.+1352   	; 0xa10 <AccountNDiz>
      Если значение датчика температуры стало больше или равно 8'С, учитывая гистерезис и флаг датчика 4 по порогу 8 был сброшен
      (означает, что значение датчика температуры было до этого меньше 8'С), то установить флаг датчика 4 по порогу 8 (означает
      превышение порога 8).
      Если значение датчика температуры стало меньше 8'С и флаг датчика 4 по порогу 8 был установлен, то флаг сбросить.
*/
      if ((Dt4<=array[0]-Hyst_t)&&(!Dt4_8))       Dt4_8=1;   //выше 9.5 градусов направление срабатывания - вверх
 4c8:	80 91 c4 00 	lds	r24, 0x00C4
 4cc:	90 91 c5 00 	lds	r25, 0x00C5
 4d0:	9c 01       	movw	r18, r24
 4d2:	2a 50       	subi	r18, 0x0A	; 10
 4d4:	30 40       	sbci	r19, 0x00	; 0
 4d6:	80 91 d2 00 	lds	r24, 0x00D2
 4da:	90 91 d3 00 	lds	r25, 0x00D3
 4de:	28 17       	cp	r18, r24
 4e0:	39 07       	cpc	r19, r25
 4e2:	38 f0       	brcs	.+14     	; 0x4f2 <__stack+0x293>
 4e4:	80 91 d5 00 	lds	r24, 0x00D5
 4e8:	88 23       	and	r24, r24
 4ea:	19 f4       	brne	.+6      	; 0x4f2 <__stack+0x293>
 4ec:	81 e0       	ldi	r24, 0x01	; 1
 4ee:	80 93 d5 00 	sts	0x00D5, r24
      if ((Dt4>array[0])&&(Dt4_8))                Dt4_8=0;   //ниже 8 градусов
 4f2:	20 91 c4 00 	lds	r18, 0x00C4
 4f6:	30 91 c5 00 	lds	r19, 0x00C5
 4fa:	80 91 d2 00 	lds	r24, 0x00D2
 4fe:	90 91 d3 00 	lds	r25, 0x00D3
 502:	28 17       	cp	r18, r24
 504:	39 07       	cpc	r19, r25
 506:	30 f4       	brcc	.+12     	; 0x514 <__stack+0x2b5>
 508:	80 91 d5 00 	lds	r24, 0x00D5
 50c:	88 23       	and	r24, r24
 50e:	11 f0       	breq	.+4      	; 0x514 <__stack+0x2b5>
 510:	10 92 d5 00 	sts	0x00D5, r1

      if ((Dt4<=(array[1]-Hyst_t))&&(!Dt4_30))    Dt4_30=1;  //выше 31.25 градусов
 514:	80 91 c6 00 	lds	r24, 0x00C6
 518:	90 91 c7 00 	lds	r25, 0x00C7
 51c:	9c 01       	movw	r18, r24
 51e:	2a 50       	subi	r18, 0x0A	; 10
 520:	30 40       	sbci	r19, 0x00	; 0
 522:	80 91 d2 00 	lds	r24, 0x00D2
 526:	90 91 d3 00 	lds	r25, 0x00D3
 52a:	28 17       	cp	r18, r24
 52c:	39 07       	cpc	r19, r25
 52e:	38 f0       	brcs	.+14     	; 0x53e <__stack+0x2df>
 530:	80 91 8b 00 	lds	r24, 0x008B
 534:	88 23       	and	r24, r24
 536:	19 f4       	brne	.+6      	; 0x53e <__stack+0x2df>
 538:	81 e0       	ldi	r24, 0x01	; 1
 53a:	80 93 8b 00 	sts	0x008B, r24
      if ((Dt4>array[1])&&(Dt4_30))               Dt4_30=0;  //ниже 30 градусов - гистерезис направление срабатывания - вверх
 53e:	20 91 c6 00 	lds	r18, 0x00C6
 542:	30 91 c7 00 	lds	r19, 0x00C7
 546:	80 91 d2 00 	lds	r24, 0x00D2
 54a:	90 91 d3 00 	lds	r25, 0x00D3
 54e:	28 17       	cp	r18, r24
 550:	39 07       	cpc	r19, r25
 552:	30 f4       	brcc	.+12     	; 0x560 <__stack+0x301>
 554:	80 91 8b 00 	lds	r24, 0x008B
 558:	88 23       	and	r24, r24
 55a:	11 f0       	breq	.+4      	; 0x560 <__stack+0x301>
 55c:	10 92 8b 00 	sts	0x008B, r1

      if ((Dt4<=array[2])&&(!Dt4_37))             Dt4_37=1;  //выше 37.0 градусов
 560:	20 91 c8 00 	lds	r18, 0x00C8
 564:	30 91 c9 00 	lds	r19, 0x00C9
 568:	80 91 d2 00 	lds	r24, 0x00D2
 56c:	90 91 d3 00 	lds	r25, 0x00D3
 570:	28 17       	cp	r18, r24
 572:	39 07       	cpc	r19, r25
 574:	38 f0       	brcs	.+14     	; 0x584 <__stack+0x325>
 576:	80 91 81 00 	lds	r24, 0x0081
 57a:	88 23       	and	r24, r24
 57c:	19 f4       	brne	.+6      	; 0x584 <__stack+0x325>
 57e:	81 e0       	ldi	r24, 0x01	; 1
 580:	80 93 81 00 	sts	0x0081, r24
      if ((Dt4>(array[2]+Hyst_t))&&(Dt4_37))      Dt4_37=0;  //ниже 36,8 градусов направление срабатывания - вниз
 584:	80 91 c8 00 	lds	r24, 0x00C8
 588:	90 91 c9 00 	lds	r25, 0x00C9
 58c:	9c 01       	movw	r18, r24
 58e:	26 5f       	subi	r18, 0xF6	; 246
 590:	3f 4f       	sbci	r19, 0xFF	; 255
 592:	80 91 d2 00 	lds	r24, 0x00D2
 596:	90 91 d3 00 	lds	r25, 0x00D3
 59a:	28 17       	cp	r18, r24
 59c:	39 07       	cpc	r19, r25
 59e:	30 f4       	brcc	.+12     	; 0x5ac <__stack+0x34d>
 5a0:	80 91 81 00 	lds	r24, 0x0081
 5a4:	88 23       	and	r24, r24
 5a6:	11 f0       	breq	.+4      	; 0x5ac <__stack+0x34d>
 5a8:	10 92 81 00 	sts	0x0081, r1

      if ((Dt5<=array[3]-(Hyst_t+20))&&(!Dt5_37)) Dt5_37=1;  //выше 44.5 градусов
 5ac:	80 91 ca 00 	lds	r24, 0x00CA
 5b0:	90 91 cb 00 	lds	r25, 0x00CB
 5b4:	9c 01       	movw	r18, r24
 5b6:	2e 51       	subi	r18, 0x1E	; 30
 5b8:	30 40       	sbci	r19, 0x00	; 0
 5ba:	80 91 7b 00 	lds	r24, 0x007B
 5be:	90 91 7c 00 	lds	r25, 0x007C
 5c2:	28 17       	cp	r18, r24
 5c4:	39 07       	cpc	r19, r25
 5c6:	38 f0       	brcs	.+14     	; 0x5d6 <__stack+0x377>
 5c8:	80 91 b4 00 	lds	r24, 0x00B4
 5cc:	88 23       	and	r24, r24
 5ce:	19 f4       	brne	.+6      	; 0x5d6 <__stack+0x377>
 5d0:	81 e0       	ldi	r24, 0x01	; 1
 5d2:	80 93 b4 00 	sts	0x00B4, r24
      if ((Dt5>array[3])&&(Dt5_37))               Dt5_37=0;  //ниже 37 градусов направление срабатывания - вверх
 5d6:	20 91 ca 00 	lds	r18, 0x00CA
 5da:	30 91 cb 00 	lds	r19, 0x00CB
 5de:	80 91 7b 00 	lds	r24, 0x007B
 5e2:	90 91 7c 00 	lds	r25, 0x007C
 5e6:	28 17       	cp	r18, r24
 5e8:	39 07       	cpc	r19, r25
 5ea:	30 f4       	brcc	.+12     	; 0x5f8 <__stack+0x399>
 5ec:	80 91 b4 00 	lds	r24, 0x00B4
 5f0:	88 23       	and	r24, r24
 5f2:	11 f0       	breq	.+4      	; 0x5f8 <__stack+0x399>
 5f4:	10 92 b4 00 	sts	0x00B4, r1

      if ((Dt5<=array[4])&&(!Dt5_95))             Dt5_95=1;  //выше 95 градусов
 5f8:	20 91 cc 00 	lds	r18, 0x00CC
 5fc:	30 91 cd 00 	lds	r19, 0x00CD
 600:	80 91 7b 00 	lds	r24, 0x007B
 604:	90 91 7c 00 	lds	r25, 0x007C
 608:	28 17       	cp	r18, r24
 60a:	39 07       	cpc	r19, r25
 60c:	38 f0       	brcs	.+14     	; 0x61c <__stack+0x3bd>
 60e:	80 91 b1 00 	lds	r24, 0x00B1
 612:	88 23       	and	r24, r24
 614:	19 f4       	brne	.+6      	; 0x61c <__stack+0x3bd>
 616:	81 e0       	ldi	r24, 0x01	; 1
 618:	80 93 b1 00 	sts	0x00B1, r24
      if ((Dt5>(array[4]+Hyst_t))&&(Dt5_95))      Dt5_95=0;  //ниже 93.5 градусов направление срабатывания - вверх
 61c:	80 91 cc 00 	lds	r24, 0x00CC
 620:	90 91 cd 00 	lds	r25, 0x00CD
 624:	9c 01       	movw	r18, r24
 626:	26 5f       	subi	r18, 0xF6	; 246
 628:	3f 4f       	sbci	r19, 0xFF	; 255
 62a:	80 91 7b 00 	lds	r24, 0x007B
 62e:	90 91 7c 00 	lds	r25, 0x007C
 632:	28 17       	cp	r18, r24
 634:	39 07       	cpc	r19, r25
 636:	30 f4       	brcc	.+12     	; 0x644 <__stack+0x3e5>
 638:	80 91 b1 00 	lds	r24, 0x00B1
 63c:	88 23       	and	r24, r24
 63e:	11 f0       	breq	.+4      	; 0x644 <__stack+0x3e5>
 640:	10 92 b1 00 	sts	0x00B1, r1

      if ((Dt6<=array[5])&&(!Dt6_115))            Dt6_115=1; //выше 115 градусов
 644:	20 91 ce 00 	lds	r18, 0x00CE
 648:	30 91 cf 00 	lds	r19, 0x00CF
 64c:	80 91 82 00 	lds	r24, 0x0082
 650:	90 91 83 00 	lds	r25, 0x0083
 654:	28 17       	cp	r18, r24
 656:	39 07       	cpc	r19, r25
 658:	38 f0       	brcs	.+14     	; 0x668 <__stack+0x409>
 65a:	80 91 76 00 	lds	r24, 0x0076
 65e:	88 23       	and	r24, r24
 660:	19 f4       	brne	.+6      	; 0x668 <__stack+0x409>
 662:	81 e0       	ldi	r24, 0x01	; 1
 664:	80 93 76 00 	sts	0x0076, r24
      if ((Dt6>(array[5]+Hyst_t))&&(Dt6_115))     Dt6_115=0; //ниже 113.5 градусов направление срабатывания - вверх
 668:	80 91 ce 00 	lds	r24, 0x00CE
 66c:	90 91 cf 00 	lds	r25, 0x00CF
 670:	9c 01       	movw	r18, r24
 672:	26 5f       	subi	r18, 0xF6	; 246
 674:	3f 4f       	sbci	r19, 0xFF	; 255
 676:	80 91 82 00 	lds	r24, 0x0082
 67a:	90 91 83 00 	lds	r25, 0x0083
 67e:	28 17       	cp	r18, r24
 680:	39 07       	cpc	r19, r25
 682:	30 f4       	brcc	.+12     	; 0x690 <__stack+0x431>
 684:	80 91 76 00 	lds	r24, 0x0076
 688:	88 23       	and	r24, r24
 68a:	11 f0       	breq	.+4      	; 0x690 <__stack+0x431>
 68c:	10 92 76 00 	sts	0x0076, r1

      if ((Dt5<=array[6])&&(!Dt5_118))            Dt5_118=1; //выше 118 градусов
 690:	20 91 d0 00 	lds	r18, 0x00D0
 694:	30 91 d1 00 	lds	r19, 0x00D1
 698:	80 91 7b 00 	lds	r24, 0x007B
 69c:	90 91 7c 00 	lds	r25, 0x007C
 6a0:	28 17       	cp	r18, r24
 6a2:	39 07       	cpc	r19, r25
 6a4:	38 f0       	brcs	.+14     	; 0x6b4 <__stack+0x455>
 6a6:	80 91 d6 00 	lds	r24, 0x00D6
 6aa:	88 23       	and	r24, r24
 6ac:	19 f4       	brne	.+6      	; 0x6b4 <__stack+0x455>
 6ae:	81 e0       	ldi	r24, 0x01	; 1
 6b0:	80 93 d6 00 	sts	0x00D6, r24
      if ((Dt5>(array[6]+Hyst_t))&&(Dt5_118))     Dt5_118=0; //ниже 116.5 градусов направление срабатывания - вверх
 6b4:	80 91 d0 00 	lds	r24, 0x00D0
 6b8:	90 91 d1 00 	lds	r25, 0x00D1
 6bc:	9c 01       	movw	r18, r24
 6be:	26 5f       	subi	r18, 0xF6	; 246
 6c0:	3f 4f       	sbci	r19, 0xFF	; 255
 6c2:	80 91 7b 00 	lds	r24, 0x007B
 6c6:	90 91 7c 00 	lds	r25, 0x007C
 6ca:	28 17       	cp	r18, r24
 6cc:	39 07       	cpc	r19, r25
 6ce:	30 f4       	brcc	.+12     	; 0x6dc <__stack+0x47d>
 6d0:	80 91 d6 00 	lds	r24, 0x00D6
 6d4:	88 23       	and	r24, r24
 6d6:	11 f0       	breq	.+4      	; 0x6dc <__stack+0x47d>
 6d8:	10 92 d6 00 	sts	0x00D6, r1
      Если значение датчика давления стало больше или равно 1 кг/см^2 и флаг датчика давления по порогу 1 был сброшен (означает,
      что значение датчика давления было до этого меньше 1 кг/см^2), то установить флаг датчика давления по порогу 1 (означает 
      превышение порога 1).
      Если значение датчика давления стало меньше 1 кг/см^2 и флаг датчика давления по порогу 1 был установлен, то флаг сбросить.
*/
      if ((Dd1>=d1_1)&&(!Dd1_1))                  Dd1_1=1;   //выше 1 кг/см кв определить пределы направление срабатывания - вверх
 6dc:	80 91 b2 00 	lds	r24, 0x00B2
 6e0:	90 91 b3 00 	lds	r25, 0x00B3
 6e4:	82 37       	cpi	r24, 0x72	; 114
 6e6:	91 05       	cpc	r25, r1
 6e8:	38 f0       	brcs	.+14     	; 0x6f8 <__stack+0x499>
 6ea:	80 91 7d 00 	lds	r24, 0x007D
 6ee:	88 23       	and	r24, r24
 6f0:	19 f4       	brne	.+6      	; 0x6f8 <__stack+0x499>
 6f2:	81 e0       	ldi	r24, 0x01	; 1
 6f4:	80 93 7d 00 	sts	0x007D, r24
      if ((Dd1<d1_1-Hyst_p)&&(Dd1_1))             Dd1_1=0;   //ниже 1 кг/см кв
 6f8:	80 91 b2 00 	lds	r24, 0x00B2
 6fc:	90 91 b3 00 	lds	r25, 0x00B3
 700:	88 36       	cpi	r24, 0x68	; 104
 702:	91 05       	cpc	r25, r1
 704:	30 f4       	brcc	.+12     	; 0x712 <__stack+0x4b3>
 706:	80 91 7d 00 	lds	r24, 0x007D
 70a:	88 23       	and	r24, r24
 70c:	11 f0       	breq	.+4      	; 0x712 <__stack+0x4b3>
 70e:	10 92 7d 00 	sts	0x007D, r1

      if ((Dd1>=d1_4+Hyst_p)&&(!Dd1_4))           Dd1_4=1;   //выше 4 кг/см кв определить пределы
 712:	80 91 b2 00 	lds	r24, 0x00B2
 716:	90 91 b3 00 	lds	r25, 0x00B3
 71a:	8f 3d       	cpi	r24, 0xDF	; 223
 71c:	91 05       	cpc	r25, r1
 71e:	38 f0       	brcs	.+14     	; 0x72e <__stack+0x4cf>
 720:	80 91 89 00 	lds	r24, 0x0089
 724:	88 23       	and	r24, r24
 726:	19 f4       	brne	.+6      	; 0x72e <__stack+0x4cf>
 728:	81 e0       	ldi	r24, 0x01	; 1
 72a:	80 93 89 00 	sts	0x0089, r24
      if ((Dd1<d1_4)&&(Dd1_4))                    Dd1_4=0;   //ниже 4 кг/см кв определить пределы 10 - гистерезис вниз направление срабатывания - вниз
 72e:	80 91 b2 00 	lds	r24, 0x00B2
 732:	90 91 b3 00 	lds	r25, 0x00B3
 736:	85 3d       	cpi	r24, 0xD5	; 213
 738:	91 05       	cpc	r25, r1
 73a:	30 f4       	brcc	.+12     	; 0x748 <__stack+0x4e9>
 73c:	80 91 89 00 	lds	r24, 0x0089
 740:	88 23       	and	r24, r24
 742:	11 f0       	breq	.+4      	; 0x748 <__stack+0x4e9>
 744:	10 92 89 00 	sts	0x0089, r1
      Условия задания флагов по порогу 500.
      Если число оборотов маховика коленвала дизеля больше или равно 500 и флаг датчика частоты оборотов был сброшен (означает,
      что число оборотов было менше 500), то установить флаг датчика частоты оборотов (означает превышение порога 500).
      Если число оборотов меньше 400 и флаг датчика частоты оборотов был установлен, то сбросить флаг датчика частоты оборотов.
*/
      if ((NDiz>=500)&&(!Nd_500))                 Nd_500=1;  //100 оборотов гистерезис
 748:	80 91 b7 00 	lds	r24, 0x00B7
 74c:	90 91 b8 00 	lds	r25, 0x00B8
 750:	31 e0       	ldi	r19, 0x01	; 1
 752:	84 3f       	cpi	r24, 0xF4	; 244
 754:	93 07       	cpc	r25, r19
 756:	38 f0       	brcs	.+14     	; 0x766 <__stack+0x507>
 758:	80 91 fd 00 	lds	r24, 0x00FD
 75c:	88 23       	and	r24, r24
 75e:	19 f4       	brne	.+6      	; 0x766 <__stack+0x507>
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	80 93 fd 00 	sts	0x00FD, r24
      if ((NDiz<400)&&(Nd_500))                   Nd_500=0;
 766:	80 91 b7 00 	lds	r24, 0x00B7
 76a:	90 91 b8 00 	lds	r25, 0x00B8
 76e:	21 e0       	ldi	r18, 0x01	; 1
 770:	80 39       	cpi	r24, 0x90	; 144
 772:	92 07       	cpc	r25, r18
 774:	30 f4       	brcc	.+12     	; 0x782 <__stack+0x523>
 776:	80 91 fd 00 	lds	r24, 0x00FD
 77a:	88 23       	and	r24, r24
 77c:	11 f0       	breq	.+4      	; 0x782 <__stack+0x523>
 77e:	10 92 fd 00 	sts	0x00FD, r1

      if ((NDiz>=1450)&&(!Nd_1450))               Nd_1450=1;
 782:	80 91 b7 00 	lds	r24, 0x00B7
 786:	90 91 b8 00 	lds	r25, 0x00B8
 78a:	35 e0       	ldi	r19, 0x05	; 5
 78c:	8a 3a       	cpi	r24, 0xAA	; 170
 78e:	93 07       	cpc	r25, r19
 790:	38 f0       	brcs	.+14     	; 0x7a0 <__stack+0x541>
 792:	80 91 bb 00 	lds	r24, 0x00BB
 796:	88 23       	and	r24, r24
 798:	19 f4       	brne	.+6      	; 0x7a0 <__stack+0x541>
 79a:	81 e0       	ldi	r24, 0x01	; 1
 79c:	80 93 bb 00 	sts	0x00BB, r24
      if ((NDiz<1350)&&(Nd_1450))                 Nd_1450=0;
 7a0:	80 91 b7 00 	lds	r24, 0x00B7
 7a4:	90 91 b8 00 	lds	r25, 0x00B8
 7a8:	25 e0       	ldi	r18, 0x05	; 5
 7aa:	86 34       	cpi	r24, 0x46	; 70
 7ac:	92 07       	cpc	r25, r18
 7ae:	30 f4       	brcc	.+12     	; 0x7bc <__stack+0x55d>
 7b0:	80 91 bb 00 	lds	r24, 0x00BB
 7b4:	88 23       	and	r24, r24
 7b6:	11 f0       	breq	.+4      	; 0x7bc <__stack+0x55d>
 7b8:	10 92 bb 00 	sts	0x00BB, r1

      if ((NDiz>=1750)&&(!Nd_1750))               Nd_1750=1;
 7bc:	80 91 b7 00 	lds	r24, 0x00B7
 7c0:	90 91 b8 00 	lds	r25, 0x00B8
 7c4:	36 e0       	ldi	r19, 0x06	; 6
 7c6:	86 3d       	cpi	r24, 0xD6	; 214
 7c8:	93 07       	cpc	r25, r19
 7ca:	38 f0       	brcs	.+14     	; 0x7da <__stack+0x57b>
 7cc:	80 91 85 00 	lds	r24, 0x0085
 7d0:	88 23       	and	r24, r24
 7d2:	19 f4       	brne	.+6      	; 0x7da <__stack+0x57b>
 7d4:	81 e0       	ldi	r24, 0x01	; 1
 7d6:	80 93 85 00 	sts	0x0085, r24
      if ((NDiz<1650)&&(Nd_1750))                 Nd_1750=0; 
 7da:	80 91 b7 00 	lds	r24, 0x00B7
 7de:	90 91 b8 00 	lds	r25, 0x00B8
 7e2:	26 e0       	ldi	r18, 0x06	; 6
 7e4:	82 37       	cpi	r24, 0x72	; 114
 7e6:	92 07       	cpc	r25, r18
 7e8:	30 f4       	brcc	.+12     	; 0x7f6 <__stack+0x597>
 7ea:	80 91 85 00 	lds	r24, 0x0085
 7ee:	88 23       	and	r24, r24
 7f0:	11 f0       	breq	.+4      	; 0x7f6 <__stack+0x597>
 7f2:	10 92 85 00 	sts	0x0085, r1

//    Объявление портов и задание их логики (светодиодная индикация):
      if (!Dt4_8)   PORTD &= ~(1<<PORTD5); else PORTD |= (1<<PORTD5); //PD5 - выше 8 град
 7f6:	80 91 d5 00 	lds	r24, 0x00D5
 7fa:	88 23       	and	r24, r24
 7fc:	41 f4       	brne	.+16     	; 0x80e <__stack+0x5af>
 7fe:	a2 e3       	ldi	r26, 0x32	; 50
 800:	b0 e0       	ldi	r27, 0x00	; 0
 802:	e2 e3       	ldi	r30, 0x32	; 50
 804:	f0 e0       	ldi	r31, 0x00	; 0
 806:	80 81       	ld	r24, Z
 808:	8f 7d       	andi	r24, 0xDF	; 223
 80a:	8c 93       	st	X, r24
 80c:	07 c0       	rjmp	.+14     	; 0x81c <__stack+0x5bd>
 80e:	a2 e3       	ldi	r26, 0x32	; 50
 810:	b0 e0       	ldi	r27, 0x00	; 0
 812:	e2 e3       	ldi	r30, 0x32	; 50
 814:	f0 e0       	ldi	r31, 0x00	; 0
 816:	80 81       	ld	r24, Z
 818:	80 62       	ori	r24, 0x20	; 32
 81a:	8c 93       	st	X, r24
      if (Dt4_30)   PORTD &= ~(1<<PORTD3); else PORTD |= (1<<PORTD3); //PD3 - ниже 30 град
 81c:	80 91 8b 00 	lds	r24, 0x008B
 820:	88 23       	and	r24, r24
 822:	41 f0       	breq	.+16     	; 0x834 <__stack+0x5d5>
 824:	a2 e3       	ldi	r26, 0x32	; 50
 826:	b0 e0       	ldi	r27, 0x00	; 0
 828:	e2 e3       	ldi	r30, 0x32	; 50
 82a:	f0 e0       	ldi	r31, 0x00	; 0
 82c:	80 81       	ld	r24, Z
 82e:	87 7f       	andi	r24, 0xF7	; 247
 830:	8c 93       	st	X, r24
 832:	07 c0       	rjmp	.+14     	; 0x842 <__stack+0x5e3>
 834:	a2 e3       	ldi	r26, 0x32	; 50
 836:	b0 e0       	ldi	r27, 0x00	; 0
 838:	e2 e3       	ldi	r30, 0x32	; 50
 83a:	f0 e0       	ldi	r31, 0x00	; 0
 83c:	80 81       	ld	r24, Z
 83e:	88 60       	ori	r24, 0x08	; 8
 840:	8c 93       	st	X, r24
      if (!Dt4_37)  PORTC &= ~(1<<PORTC2); else PORTC |= (1<<PORTC2); //PС2 - ниже 37 град 37+красн
 842:	80 91 81 00 	lds	r24, 0x0081
 846:	88 23       	and	r24, r24
 848:	41 f4       	brne	.+16     	; 0x85a <__stack+0x5fb>
 84a:	a5 e3       	ldi	r26, 0x35	; 53
 84c:	b0 e0       	ldi	r27, 0x00	; 0
 84e:	e5 e3       	ldi	r30, 0x35	; 53
 850:	f0 e0       	ldi	r31, 0x00	; 0
 852:	80 81       	ld	r24, Z
 854:	8b 7f       	andi	r24, 0xFB	; 251
 856:	8c 93       	st	X, r24
 858:	07 c0       	rjmp	.+14     	; 0x868 <__stack+0x609>
 85a:	a5 e3       	ldi	r26, 0x35	; 53
 85c:	b0 e0       	ldi	r27, 0x00	; 0
 85e:	e5 e3       	ldi	r30, 0x35	; 53
 860:	f0 e0       	ldi	r31, 0x00	; 0
 862:	80 81       	ld	r24, Z
 864:	84 60       	ori	r24, 0x04	; 4
 866:	8c 93       	st	X, r24

      if (Dt5_37)   PORTC &= ~(1<<PORTC4); else PORTC |= (1<<PORTC4); //PC4 - выше 45 град зеленый
 868:	80 91 b4 00 	lds	r24, 0x00B4
 86c:	88 23       	and	r24, r24
 86e:	41 f0       	breq	.+16     	; 0x880 <__stack+0x621>
 870:	a5 e3       	ldi	r26, 0x35	; 53
 872:	b0 e0       	ldi	r27, 0x00	; 0
 874:	e5 e3       	ldi	r30, 0x35	; 53
 876:	f0 e0       	ldi	r31, 0x00	; 0
 878:	80 81       	ld	r24, Z
 87a:	8f 7e       	andi	r24, 0xEF	; 239
 87c:	8c 93       	st	X, r24
 87e:	07 c0       	rjmp	.+14     	; 0x88e <__stack+0x62f>
 880:	a5 e3       	ldi	r26, 0x35	; 53
 882:	b0 e0       	ldi	r27, 0x00	; 0
 884:	e5 e3       	ldi	r30, 0x35	; 53
 886:	f0 e0       	ldi	r31, 0x00	; 0
 888:	80 81       	ld	r24, Z
 88a:	80 61       	ori	r24, 0x10	; 16
 88c:	8c 93       	st	X, r24
      if (!Dt5_95)  PORTC &= ~(1<<PORTC0); else PORTC |= (1<<PORTC0); //PC0 - выше 95 град
 88e:	80 91 b1 00 	lds	r24, 0x00B1
 892:	88 23       	and	r24, r24
 894:	41 f4       	brne	.+16     	; 0x8a6 <__stack+0x647>
 896:	a5 e3       	ldi	r26, 0x35	; 53
 898:	b0 e0       	ldi	r27, 0x00	; 0
 89a:	e5 e3       	ldi	r30, 0x35	; 53
 89c:	f0 e0       	ldi	r31, 0x00	; 0
 89e:	80 81       	ld	r24, Z
 8a0:	8e 7f       	andi	r24, 0xFE	; 254
 8a2:	8c 93       	st	X, r24
 8a4:	07 c0       	rjmp	.+14     	; 0x8b4 <__stack+0x655>
 8a6:	a5 e3       	ldi	r26, 0x35	; 53
 8a8:	b0 e0       	ldi	r27, 0x00	; 0
 8aa:	e5 e3       	ldi	r30, 0x35	; 53
 8ac:	f0 e0       	ldi	r31, 0x00	; 0
 8ae:	80 81       	ld	r24, Z
 8b0:	81 60       	ori	r24, 0x01	; 1
 8b2:	8c 93       	st	X, r24
	  if (Dt6_115)  PORTC &= ~(1<<PORTC3); else PORTC |= (1<<PORTC3); //PС3 - выше 115 град и 115 гр. инверсная
 8b4:	80 91 76 00 	lds	r24, 0x0076
 8b8:	88 23       	and	r24, r24
 8ba:	41 f0       	breq	.+16     	; 0x8cc <__stack+0x66d>
 8bc:	a5 e3       	ldi	r26, 0x35	; 53
 8be:	b0 e0       	ldi	r27, 0x00	; 0
 8c0:	e5 e3       	ldi	r30, 0x35	; 53
 8c2:	f0 e0       	ldi	r31, 0x00	; 0
 8c4:	80 81       	ld	r24, Z
 8c6:	87 7f       	andi	r24, 0xF7	; 247
 8c8:	8c 93       	st	X, r24
 8ca:	07 c0       	rjmp	.+14     	; 0x8da <__stack+0x67b>
 8cc:	a5 e3       	ldi	r26, 0x35	; 53
 8ce:	b0 e0       	ldi	r27, 0x00	; 0
 8d0:	e5 e3       	ldi	r30, 0x35	; 53
 8d2:	f0 e0       	ldi	r31, 0x00	; 0
 8d4:	80 81       	ld	r24, Z
 8d6:	88 60       	ori	r24, 0x08	; 8
 8d8:	8c 93       	st	X, r24
      if (Dt5_118)  PORTC &= ~(1<<PORTC1); else PORTC |= (1<<PORTC1); //PC1 - выше 118 град логика работы 118гр.
 8da:	80 91 d6 00 	lds	r24, 0x00D6
 8de:	88 23       	and	r24, r24
 8e0:	41 f0       	breq	.+16     	; 0x8f2 <__stack+0x693>
 8e2:	a5 e3       	ldi	r26, 0x35	; 53
 8e4:	b0 e0       	ldi	r27, 0x00	; 0
 8e6:	e5 e3       	ldi	r30, 0x35	; 53
 8e8:	f0 e0       	ldi	r31, 0x00	; 0
 8ea:	80 81       	ld	r24, Z
 8ec:	8d 7f       	andi	r24, 0xFD	; 253
 8ee:	8c 93       	st	X, r24
 8f0:	07 c0       	rjmp	.+14     	; 0x900 <__stack+0x6a1>
 8f2:	a5 e3       	ldi	r26, 0x35	; 53
 8f4:	b0 e0       	ldi	r27, 0x00	; 0
 8f6:	e5 e3       	ldi	r30, 0x35	; 53
 8f8:	f0 e0       	ldi	r31, 0x00	; 0
 8fa:	80 81       	ld	r24, Z
 8fc:	82 60       	ori	r24, 0x02	; 2
 8fe:	8c 93       	st	X, r24

      if (!Dd1_1)   PORTD &= ~(1<<PORTD0); else PORTD |= (1<<PORTD0); //PD0 - выше 1 кг
 900:	80 91 7d 00 	lds	r24, 0x007D
 904:	88 23       	and	r24, r24
 906:	41 f4       	brne	.+16     	; 0x918 <__stack+0x6b9>
 908:	a2 e3       	ldi	r26, 0x32	; 50
 90a:	b0 e0       	ldi	r27, 0x00	; 0
 90c:	e2 e3       	ldi	r30, 0x32	; 50
 90e:	f0 e0       	ldi	r31, 0x00	; 0
 910:	80 81       	ld	r24, Z
 912:	8e 7f       	andi	r24, 0xFE	; 254
 914:	8c 93       	st	X, r24
 916:	07 c0       	rjmp	.+14     	; 0x926 <__stack+0x6c7>
 918:	a2 e3       	ldi	r26, 0x32	; 50
 91a:	b0 e0       	ldi	r27, 0x00	; 0
 91c:	e2 e3       	ldi	r30, 0x32	; 50
 91e:	f0 e0       	ldi	r31, 0x00	; 0
 920:	80 81       	ld	r24, Z
 922:	81 60       	ori	r24, 0x01	; 1
 924:	8c 93       	st	X, r24
      if (Dd1_4)    PORTD &= ~(1<<PORTD1); else PORTD |= (1<<PORTD1); //PD1 - ниже 4 кг
 926:	80 91 89 00 	lds	r24, 0x0089
 92a:	88 23       	and	r24, r24
 92c:	41 f0       	breq	.+16     	; 0x93e <__stack+0x6df>
 92e:	a2 e3       	ldi	r26, 0x32	; 50
 930:	b0 e0       	ldi	r27, 0x00	; 0
 932:	e2 e3       	ldi	r30, 0x32	; 50
 934:	f0 e0       	ldi	r31, 0x00	; 0
 936:	80 81       	ld	r24, Z
 938:	8d 7f       	andi	r24, 0xFD	; 253
 93a:	8c 93       	st	X, r24
 93c:	07 c0       	rjmp	.+14     	; 0x94c <__stack+0x6ed>
 93e:	a2 e3       	ldi	r26, 0x32	; 50
 940:	b0 e0       	ldi	r27, 0x00	; 0
 942:	e2 e3       	ldi	r30, 0x32	; 50
 944:	f0 e0       	ldi	r31, 0x00	; 0
 946:	80 81       	ld	r24, Z
 948:	82 60       	ori	r24, 0x02	; 2
 94a:	8c 93       	st	X, r24
   
      if (!Nd_500)  PORTD &= ~(1<<PORTD2); else PORTD |= (1<<PORTD2); //PD2 - выше 500
 94c:	80 91 fd 00 	lds	r24, 0x00FD
 950:	88 23       	and	r24, r24
 952:	41 f4       	brne	.+16     	; 0x964 <__stack+0x705>
 954:	a2 e3       	ldi	r26, 0x32	; 50
 956:	b0 e0       	ldi	r27, 0x00	; 0
 958:	e2 e3       	ldi	r30, 0x32	; 50
 95a:	f0 e0       	ldi	r31, 0x00	; 0
 95c:	80 81       	ld	r24, Z
 95e:	8b 7f       	andi	r24, 0xFB	; 251
 960:	8c 93       	st	X, r24
 962:	07 c0       	rjmp	.+14     	; 0x972 <__stack+0x713>
 964:	a2 e3       	ldi	r26, 0x32	; 50
 966:	b0 e0       	ldi	r27, 0x00	; 0
 968:	e2 e3       	ldi	r30, 0x32	; 50
 96a:	f0 e0       	ldi	r31, 0x00	; 0
 96c:	80 81       	ld	r24, Z
 96e:	84 60       	ori	r24, 0x04	; 4
 970:	8c 93       	st	X, r24
      if (!Nd_1450) PORTD &= ~(1<<PORTD4); else PORTD |= (1<<PORTD4); //PD4 - выше 1450
 972:	80 91 bb 00 	lds	r24, 0x00BB
 976:	88 23       	and	r24, r24
 978:	41 f4       	brne	.+16     	; 0x98a <__stack+0x72b>
 97a:	a2 e3       	ldi	r26, 0x32	; 50
 97c:	b0 e0       	ldi	r27, 0x00	; 0
 97e:	e2 e3       	ldi	r30, 0x32	; 50
 980:	f0 e0       	ldi	r31, 0x00	; 0
 982:	80 81       	ld	r24, Z
 984:	8f 7e       	andi	r24, 0xEF	; 239
 986:	8c 93       	st	X, r24
 988:	07 c0       	rjmp	.+14     	; 0x998 <__stack+0x739>
 98a:	a2 e3       	ldi	r26, 0x32	; 50
 98c:	b0 e0       	ldi	r27, 0x00	; 0
 98e:	e2 e3       	ldi	r30, 0x32	; 50
 990:	f0 e0       	ldi	r31, 0x00	; 0
 992:	80 81       	ld	r24, Z
 994:	80 61       	ori	r24, 0x10	; 16
 996:	8c 93       	st	X, r24
      if (Nd_1750)  PORTC &= ~(1<<PORTC5); else PORTC |= (1<<PORTC5); //PC5 - выше 1750
 998:	80 91 85 00 	lds	r24, 0x0085
 99c:	88 23       	and	r24, r24
 99e:	41 f0       	breq	.+16     	; 0x9b0 <__stack+0x751>
 9a0:	a5 e3       	ldi	r26, 0x35	; 53
 9a2:	b0 e0       	ldi	r27, 0x00	; 0
 9a4:	e5 e3       	ldi	r30, 0x35	; 53
 9a6:	f0 e0       	ldi	r31, 0x00	; 0
 9a8:	80 81       	ld	r24, Z
 9aa:	8f 7d       	andi	r24, 0xDF	; 223
 9ac:	8c 93       	st	X, r24
 9ae:	89 cd       	rjmp	.-1262   	; 0x4c2 <__stack+0x263>
 9b0:	a5 e3       	ldi	r26, 0x35	; 53
 9b2:	b0 e0       	ldi	r27, 0x00	; 0
 9b4:	e5 e3       	ldi	r30, 0x35	; 53
 9b6:	f0 e0       	ldi	r31, 0x00	; 0
 9b8:	80 81       	ld	r24, Z
 9ba:	80 62       	ori	r24, 0x20	; 32
 9bc:	8c 93       	st	X, r24
 9be:	81 cd       	rjmp	.-1278   	; 0x4c2 <__stack+0x263>

000009c0 <InitAd>:
    }
  }
}

void InitAd(void)
{
 9c0:	df 93       	push	r29
 9c2:	cf 93       	push	r28
 9c4:	cd b7       	in	r28, 0x3d	; 61
 9c6:	de b7       	in	r29, 0x3e	; 62
  ADMUX = (1<<REFS0);                        //internal Aref with capacitor 0100 0000 (ADC0, single-ended, gain=1)
 9c8:	e7 e2       	ldi	r30, 0x27	; 39
 9ca:	f0 e0       	ldi	r31, 0x00	; 0
 9cc:	80 e4       	ldi	r24, 0x40	; 64
 9ce:	80 83       	st	Z, r24
  CtAd = CtAd0;                              //63
 9d0:	8f e3       	ldi	r24, 0x3F	; 63
 9d2:	80 93 d4 00 	sts	0x00D4, r24
  NumberAd = 0;
 9d6:	10 92 80 00 	sts	0x0080, r1
  ADCSRA = 0; 
 9da:	e6 e2       	ldi	r30, 0x26	; 38
 9dc:	f0 e0       	ldi	r31, 0x00	; 0
 9de:	10 82       	st	Z, r1
  ADCSRA |=(1<<ADEN);                        //enable AD
 9e0:	a6 e2       	ldi	r26, 0x26	; 38
 9e2:	b0 e0       	ldi	r27, 0x00	; 0
 9e4:	e6 e2       	ldi	r30, 0x26	; 38
 9e6:	f0 e0       	ldi	r31, 0x00	; 0
 9e8:	80 81       	ld	r24, Z
 9ea:	80 68       	ori	r24, 0x80	; 128
 9ec:	8c 93       	st	X, r24
  ADCSRA |=(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); //1/128 - 125 kHz
 9ee:	a6 e2       	ldi	r26, 0x26	; 38
 9f0:	b0 e0       	ldi	r27, 0x00	; 0
 9f2:	e6 e2       	ldi	r30, 0x26	; 38
 9f4:	f0 e0       	ldi	r31, 0x00	; 0
 9f6:	80 81       	ld	r24, Z
 9f8:	87 60       	ori	r24, 0x07	; 7
 9fa:	8c 93       	st	X, r24
  ADCSRA |=(1<<ADSC);                        //Start
 9fc:	a6 e2       	ldi	r26, 0x26	; 38
 9fe:	b0 e0       	ldi	r27, 0x00	; 0
 a00:	e6 e2       	ldi	r30, 0x26	; 38
 a02:	f0 e0       	ldi	r31, 0x00	; 0
 a04:	80 81       	ld	r24, Z
 a06:	80 64       	ori	r24, 0x40	; 64
 a08:	8c 93       	st	X, r24
}
 a0a:	cf 91       	pop	r28
 a0c:	df 91       	pop	r29
 a0e:	08 95       	ret

00000a10 <AccountNDiz>:

void AccountNDiz(void)          //подпрограмма вычисления частоты вращения маховика коленвала дизеля
{
 a10:	df 93       	push	r29
 a12:	cf 93       	push	r28
 a14:	00 d0       	rcall	.+0      	; 0xa16 <AccountNDiz+0x6>
 a16:	00 d0       	rcall	.+0      	; 0xa18 <AccountNDiz+0x8>
 a18:	00 d0       	rcall	.+0      	; 0xa1a <AccountNDiz+0xa>
 a1a:	cd b7       	in	r28, 0x3d	; 61
 a1c:	de b7       	in	r29, 0x3e	; 62
  unsigned long R1;             //переменная количества оборотов
  unsigned char R0;             //номер элемента массива выборок количества оборотов
  unsigned char NDiz_invalid=0; //флаг неправильной работы
 a1e:	19 82       	std	Y+1, r1	; 0x01
  {
    R1=0;
 a20:	1b 82       	std	Y+3, r1	; 0x03
 a22:	1c 82       	std	Y+4, r1	; 0x04
 a24:	1d 82       	std	Y+5, r1	; 0x05
 a26:	1e 82       	std	Y+6, r1	; 0x06
    for (R0=0; R0<=15; ++R0)
 a28:	1a 82       	std	Y+2, r1	; 0x02
 a2a:	38 c0       	rjmp	.+112    	; 0xa9c <AccountNDiz+0x8c>
    {
      if ((TDizTemp[R0]==0xffff)||(TDizTemp[R0]==0)) NDiz_invalid=1; //выставление флага если расчет кол-ва оборотов будет неверный
 a2c:	8a 81       	ldd	r24, Y+2	; 0x02
 a2e:	88 2f       	mov	r24, r24
 a30:	90 e0       	ldi	r25, 0x00	; 0
 a32:	88 0f       	add	r24, r24
 a34:	99 1f       	adc	r25, r25
 a36:	fc 01       	movw	r30, r24
 a38:	e4 57       	subi	r30, 0x74	; 116
 a3a:	ff 4f       	sbci	r31, 0xFF	; 255
 a3c:	80 81       	ld	r24, Z
 a3e:	91 81       	ldd	r25, Z+1	; 0x01
 a40:	2f ef       	ldi	r18, 0xFF	; 255
 a42:	8f 3f       	cpi	r24, 0xFF	; 255
 a44:	92 07       	cpc	r25, r18
 a46:	61 f0       	breq	.+24     	; 0xa60 <AccountNDiz+0x50>
 a48:	8a 81       	ldd	r24, Y+2	; 0x02
 a4a:	88 2f       	mov	r24, r24
 a4c:	90 e0       	ldi	r25, 0x00	; 0
 a4e:	88 0f       	add	r24, r24
 a50:	99 1f       	adc	r25, r25
 a52:	fc 01       	movw	r30, r24
 a54:	e4 57       	subi	r30, 0x74	; 116
 a56:	ff 4f       	sbci	r31, 0xFF	; 255
 a58:	80 81       	ld	r24, Z
 a5a:	91 81       	ldd	r25, Z+1	; 0x01
 a5c:	00 97       	sbiw	r24, 0x00	; 0
 a5e:	11 f4       	brne	.+4      	; 0xa64 <AccountNDiz+0x54>
 a60:	81 e0       	ldi	r24, 0x01	; 1
 a62:	89 83       	std	Y+1, r24	; 0x01
      R1+=TDizTemp[R0]; //суммирование всех 16 выборок
 a64:	8a 81       	ldd	r24, Y+2	; 0x02
 a66:	88 2f       	mov	r24, r24
 a68:	90 e0       	ldi	r25, 0x00	; 0
 a6a:	88 0f       	add	r24, r24
 a6c:	99 1f       	adc	r25, r25
 a6e:	fc 01       	movw	r30, r24
 a70:	e4 57       	subi	r30, 0x74	; 116
 a72:	ff 4f       	sbci	r31, 0xFF	; 255
 a74:	80 81       	ld	r24, Z
 a76:	91 81       	ldd	r25, Z+1	; 0x01
 a78:	9c 01       	movw	r18, r24
 a7a:	40 e0       	ldi	r20, 0x00	; 0
 a7c:	50 e0       	ldi	r21, 0x00	; 0
 a7e:	8b 81       	ldd	r24, Y+3	; 0x03
 a80:	9c 81       	ldd	r25, Y+4	; 0x04
 a82:	ad 81       	ldd	r26, Y+5	; 0x05
 a84:	be 81       	ldd	r27, Y+6	; 0x06
 a86:	82 0f       	add	r24, r18
 a88:	93 1f       	adc	r25, r19
 a8a:	a4 1f       	adc	r26, r20
 a8c:	b5 1f       	adc	r27, r21
 a8e:	8b 83       	std	Y+3, r24	; 0x03
 a90:	9c 83       	std	Y+4, r25	; 0x04
 a92:	ad 83       	std	Y+5, r26	; 0x05
 a94:	be 83       	std	Y+6, r27	; 0x06
  unsigned long R1;             //переменная количества оборотов
  unsigned char R0;             //номер элемента массива выборок количества оборотов
  unsigned char NDiz_invalid=0; //флаг неправильной работы
  {
    R1=0;
    for (R0=0; R0<=15; ++R0)
 a96:	8a 81       	ldd	r24, Y+2	; 0x02
 a98:	8f 5f       	subi	r24, 0xFF	; 255
 a9a:	8a 83       	std	Y+2, r24	; 0x02
 a9c:	8a 81       	ldd	r24, Y+2	; 0x02
 a9e:	80 31       	cpi	r24, 0x10	; 16
 aa0:	28 f2       	brcs	.-118    	; 0xa2c <AccountNDiz+0x1c>
    {
      if ((TDizTemp[R0]==0xffff)||(TDizTemp[R0]==0)) NDiz_invalid=1; //выставление флага если расчет кол-ва оборотов будет неверный
      R1+=TDizTemp[R0]; //суммирование всех 16 выборок
    }
    R1>>=4; //вычисление среднего значения
 aa2:	8b 81       	ldd	r24, Y+3	; 0x03
 aa4:	9c 81       	ldd	r25, Y+4	; 0x04
 aa6:	ad 81       	ldd	r26, Y+5	; 0x05
 aa8:	be 81       	ldd	r27, Y+6	; 0x06
 aaa:	68 94       	set
 aac:	13 f8       	bld	r1, 3
 aae:	b6 95       	lsr	r27
 ab0:	a7 95       	ror	r26
 ab2:	97 95       	ror	r25
 ab4:	87 95       	ror	r24
 ab6:	16 94       	lsr	r1
 ab8:	d1 f7       	brne	.-12     	; 0xaae <AccountNDiz+0x9e>
 aba:	8b 83       	std	Y+3, r24	; 0x03
 abc:	9c 83       	std	Y+4, r25	; 0x04
 abe:	ad 83       	std	Y+5, r26	; 0x05
 ac0:	be 83       	std	Y+6, r27	; 0x06
    if((R1>62330)||(NDiz_Overflow==1)) // если результат больше 62330 или установлен флаг переполнения, то обороты = 0
 ac2:	8b 81       	ldd	r24, Y+3	; 0x03
 ac4:	9c 81       	ldd	r25, Y+4	; 0x04
 ac6:	ad 81       	ldd	r26, Y+5	; 0x05
 ac8:	be 81       	ldd	r27, Y+6	; 0x06
 aca:	8b 37       	cpi	r24, 0x7B	; 123
 acc:	23 ef       	ldi	r18, 0xF3	; 243
 ace:	92 07       	cpc	r25, r18
 ad0:	20 e0       	ldi	r18, 0x00	; 0
 ad2:	a2 07       	cpc	r26, r18
 ad4:	20 e0       	ldi	r18, 0x00	; 0
 ad6:	b2 07       	cpc	r27, r18
 ad8:	20 f4       	brcc	.+8      	; 0xae2 <AccountNDiz+0xd2>
 ada:	80 91 72 00 	lds	r24, 0x0072
 ade:	81 30       	cpi	r24, 0x01	; 1
 ae0:	29 f4       	brne	.+10     	; 0xaec <AccountNDiz+0xdc>
      NDiz=0;
 ae2:	10 92 b8 00 	sts	0x00B8, r1
 ae6:	10 92 b7 00 	sts	0x00B7, r1
 aea:	33 c0       	rjmp	.+102    	; 0xb52 <AccountNDiz+0x142>

    else
    {
      if (!NDiz_invalid)
 aec:	89 81       	ldd	r24, Y+1	; 0x01
 aee:	88 23       	and	r24, r24
 af0:	c9 f4       	brne	.+50     	; 0xb24 <AccountNDiz+0x114>
      {
        R1=8421000/R1;  //R1 = 62330 - 140 оборотов в минуту или 2,33(3) в сек
 af2:	88 e8       	ldi	r24, 0x88	; 136
 af4:	9e e7       	ldi	r25, 0x7E	; 126
 af6:	a0 e8       	ldi	r26, 0x80	; 128
 af8:	b0 e0       	ldi	r27, 0x00	; 0
 afa:	2b 81       	ldd	r18, Y+3	; 0x03
 afc:	3c 81       	ldd	r19, Y+4	; 0x04
 afe:	4d 81       	ldd	r20, Y+5	; 0x05
 b00:	5e 81       	ldd	r21, Y+6	; 0x06
 b02:	bc 01       	movw	r22, r24
 b04:	cd 01       	movw	r24, r26
 b06:	21 d2       	rcall	.+1090   	; 0xf4a <__udivmodsi4>
 b08:	da 01       	movw	r26, r20
 b0a:	c9 01       	movw	r24, r18
 b0c:	8b 83       	std	Y+3, r24	; 0x03
 b0e:	9c 83       	std	Y+4, r25	; 0x04
 b10:	ad 83       	std	Y+5, r26	; 0x05
 b12:	be 83       	std	Y+6, r27	; 0x06
        NDiz=R1;
 b14:	8b 81       	ldd	r24, Y+3	; 0x03
 b16:	9c 81       	ldd	r25, Y+4	; 0x04
 b18:	90 93 b8 00 	sts	0x00B8, r25
 b1c:	80 93 b7 00 	sts	0x00B7, r24
        InvCounter=0;   //обнуление счетчика инвалидности
 b20:	10 92 7e 00 	sts	0x007E, r1
      }                 //R1 = 2909 - 3000оборотов в минуту или 50 в секунду
      if (NDiz_invalid)
 b24:	89 81       	ldd	r24, Y+1	; 0x01
 b26:	88 23       	and	r24, r24
 b28:	a1 f0       	breq	.+40     	; 0xb52 <AccountNDiz+0x142>
      {
        InvCounter++;
 b2a:	80 91 7e 00 	lds	r24, 0x007E
 b2e:	8f 5f       	subi	r24, 0xFF	; 255
 b30:	80 93 7e 00 	sts	0x007E, r24
        if (InvCounter>=10)
 b34:	80 91 7e 00 	lds	r24, 0x007E
 b38:	8a 30       	cpi	r24, 0x0A	; 10
 b3a:	58 f0       	brcs	.+22     	; 0xb52 <AccountNDiz+0x142>
        {
          if (InvCounter>=250) InvCounter = 4; //колцевание
 b3c:	80 91 7e 00 	lds	r24, 0x007E
 b40:	8a 3f       	cpi	r24, 0xFA	; 250
 b42:	18 f0       	brcs	.+6      	; 0xb4a <AccountNDiz+0x13a>
 b44:	84 e0       	ldi	r24, 0x04	; 4
 b46:	80 93 7e 00 	sts	0x007E, r24
          NDiz = 0;
 b4a:	10 92 b8 00 	sts	0x00B8, r1
 b4e:	10 92 b7 00 	sts	0x00B7, r1
        }
      }
    }
  }
}
 b52:	26 96       	adiw	r28, 0x06	; 6
 b54:	0f b6       	in	r0, 0x3f	; 63
 b56:	f8 94       	cli
 b58:	de bf       	out	0x3e, r29	; 62
 b5a:	0f be       	out	0x3f, r0	; 63
 b5c:	cd bf       	out	0x3d, r28	; 61
 b5e:	cf 91       	pop	r28
 b60:	df 91       	pop	r29
 b62:	08 95       	ret

00000b64 <AccountADC>:
//для УД-45 частота импульсов на 1500оборотов=2850
//таймер досчитывает до 5614
//коэффициент деления=

void AccountADC(void)
{
 b64:	df 93       	push	r29
 b66:	cf 93       	push	r28
 b68:	cd b7       	in	r28, 0x3d	; 61
 b6a:	de b7       	in	r29, 0x3e	; 62
  Dd1=AdResult[0];
 b6c:	80 91 e5 00 	lds	r24, 0x00E5
 b70:	90 91 e6 00 	lds	r25, 0x00E6
 b74:	90 93 b3 00 	sts	0x00B3, r25
 b78:	80 93 b2 00 	sts	0x00B2, r24
  Dt4=AdResult[1];
 b7c:	80 91 e7 00 	lds	r24, 0x00E7
 b80:	90 91 e8 00 	lds	r25, 0x00E8
 b84:	90 93 d3 00 	sts	0x00D3, r25
 b88:	80 93 d2 00 	sts	0x00D2, r24
  Dt5=AdResult[2];
 b8c:	80 91 e9 00 	lds	r24, 0x00E9
 b90:	90 91 ea 00 	lds	r25, 0x00EA
 b94:	90 93 7c 00 	sts	0x007C, r25
 b98:	80 93 7b 00 	sts	0x007B, r24
  Dt6=AdResult[3];
 b9c:	80 91 eb 00 	lds	r24, 0x00EB
 ba0:	90 91 ec 00 	lds	r25, 0x00EC
 ba4:	90 93 83 00 	sts	0x0083, r25
 ba8:	80 93 82 00 	sts	0x0082, r24
}
 bac:	cf 91       	pop	r28
 bae:	df 91       	pop	r29
 bb0:	08 95       	ret

00000bb2 <__vector_5>:

SIGNAL(SIG_INPUT_CAPTURE1)
{
 bb2:	1f 92       	push	r1
 bb4:	0f 92       	push	r0
 bb6:	0f b6       	in	r0, 0x3f	; 63
 bb8:	0f 92       	push	r0
 bba:	11 24       	eor	r1, r1
 bbc:	2f 93       	push	r18
 bbe:	3f 93       	push	r19
 bc0:	4f 93       	push	r20
 bc2:	5f 93       	push	r21
 bc4:	8f 93       	push	r24
 bc6:	9f 93       	push	r25
 bc8:	ef 93       	push	r30
 bca:	ff 93       	push	r31
 bcc:	df 93       	push	r29
 bce:	cf 93       	push	r28
 bd0:	cd b7       	in	r28, 0x3d	; 61
 bd2:	de b7       	in	r29, 0x3e	; 62
  ICR1_value=ICR1; //чтение значения как можно раньше
 bd4:	e6 e4       	ldi	r30, 0x46	; 70
 bd6:	f0 e0       	ldi	r31, 0x00	; 0
 bd8:	80 81       	ld	r24, Z
 bda:	91 81       	ldd	r25, Z+1	; 0x01
 bdc:	90 93 bf 00 	sts	0x00BF, r25
 be0:	80 93 be 00 	sts	0x00BE, r24

  if ((ICR1_value>ICR1Old)&&(CtOverLow==16))
 be4:	20 91 be 00 	lds	r18, 0x00BE
 be8:	30 91 bf 00 	lds	r19, 0x00BF
 bec:	80 91 86 00 	lds	r24, 0x0086
 bf0:	90 91 87 00 	lds	r25, 0x0087
 bf4:	82 17       	cp	r24, r18
 bf6:	93 07       	cpc	r25, r19
 bf8:	08 f0       	brcs	.+2      	; 0xbfc <__vector_5+0x4a>
 bfa:	43 c0       	rjmp	.+134    	; 0xc82 <__vector_5+0xd0>
 bfc:	80 91 7f 00 	lds	r24, 0x007F
 c00:	80 31       	cpi	r24, 0x10	; 16
 c02:	09 f0       	breq	.+2      	; 0xc06 <__vector_5+0x54>
 c04:	3e c0       	rjmp	.+124    	; 0xc82 <__vector_5+0xd0>
  {
    TDizTemp[CtTDiz]=ICR1_value-ICR1Old; //разница между двумя измерениями
 c06:	80 91 84 00 	lds	r24, 0x0084
 c0a:	48 2f       	mov	r20, r24
 c0c:	50 e0       	ldi	r21, 0x00	; 0
 c0e:	20 91 be 00 	lds	r18, 0x00BE
 c12:	30 91 bf 00 	lds	r19, 0x00BF
 c16:	80 91 86 00 	lds	r24, 0x0086
 c1a:	90 91 87 00 	lds	r25, 0x0087
 c1e:	28 1b       	sub	r18, r24
 c20:	39 0b       	sbc	r19, r25
 c22:	ca 01       	movw	r24, r20
 c24:	88 0f       	add	r24, r24
 c26:	99 1f       	adc	r25, r25
 c28:	fc 01       	movw	r30, r24
 c2a:	e4 57       	subi	r30, 0x74	; 116
 c2c:	ff 4f       	sbci	r31, 0xFF	; 255
 c2e:	31 83       	std	Z+1, r19	; 0x01
 c30:	20 83       	st	Z, r18
    if (TDizTemp[CtTDiz]<100)
 c32:	80 91 84 00 	lds	r24, 0x0084
 c36:	88 2f       	mov	r24, r24
 c38:	90 e0       	ldi	r25, 0x00	; 0
 c3a:	88 0f       	add	r24, r24
 c3c:	99 1f       	adc	r25, r25
 c3e:	fc 01       	movw	r30, r24
 c40:	e4 57       	subi	r30, 0x74	; 116
 c42:	ff 4f       	sbci	r31, 0xFF	; 255
 c44:	80 81       	ld	r24, Z
 c46:	91 81       	ldd	r25, Z+1	; 0x01
 c48:	84 36       	cpi	r24, 0x64	; 100
 c4a:	91 05       	cpc	r25, r1
 c4c:	68 f4       	brcc	.+26     	; 0xc68 <__vector_5+0xb6>
      TDizTemp[CtTDiz]=0xffff; //FFFF - невозможное значение
 c4e:	80 91 84 00 	lds	r24, 0x0084
 c52:	88 2f       	mov	r24, r24
 c54:	90 e0       	ldi	r25, 0x00	; 0
 c56:	88 0f       	add	r24, r24
 c58:	99 1f       	adc	r25, r25
 c5a:	fc 01       	movw	r30, r24
 c5c:	e4 57       	subi	r30, 0x74	; 116
 c5e:	ff 4f       	sbci	r31, 0xFF	; 255
 c60:	8f ef       	ldi	r24, 0xFF	; 255
 c62:	9f ef       	ldi	r25, 0xFF	; 255
 c64:	91 83       	std	Z+1, r25	; 0x01
 c66:	80 83       	st	Z, r24

    if (CtTDiz) --CtTDiz;
 c68:	80 91 84 00 	lds	r24, 0x0084
 c6c:	88 23       	and	r24, r24
 c6e:	31 f0       	breq	.+12     	; 0xc7c <__vector_5+0xca>
 c70:	80 91 84 00 	lds	r24, 0x0084
 c74:	81 50       	subi	r24, 0x01	; 1
 c76:	80 93 84 00 	sts	0x0084, r24
 c7a:	03 c0       	rjmp	.+6      	; 0xc82 <__vector_5+0xd0>
    else        CtTDiz=15;     //16 выборок
 c7c:	8f e0       	ldi	r24, 0x0F	; 15
 c7e:	80 93 84 00 	sts	0x0084, r24
  }
  ICR1Old=ICR1_value;
 c82:	80 91 be 00 	lds	r24, 0x00BE
 c86:	90 91 bf 00 	lds	r25, 0x00BF
 c8a:	90 93 87 00 	sts	0x0087, r25
 c8e:	80 93 86 00 	sts	0x0086, r24
  CtOverLow=16; //16 - переполнений до установки флага 0 оборотов.
 c92:	80 e1       	ldi	r24, 0x10	; 16
 c94:	80 93 7f 00 	sts	0x007F, r24
  NDiz_Overflow=0;
 c98:	10 92 72 00 	sts	0x0072, r1
}
 c9c:	cf 91       	pop	r28
 c9e:	df 91       	pop	r29
 ca0:	ff 91       	pop	r31
 ca2:	ef 91       	pop	r30
 ca4:	9f 91       	pop	r25
 ca6:	8f 91       	pop	r24
 ca8:	5f 91       	pop	r21
 caa:	4f 91       	pop	r20
 cac:	3f 91       	pop	r19
 cae:	2f 91       	pop	r18
 cb0:	0f 90       	pop	r0
 cb2:	0f be       	out	0x3f, r0	; 63
 cb4:	0f 90       	pop	r0
 cb6:	1f 90       	pop	r1
 cb8:	18 95       	reti

00000cba <__vector_8>:

SIGNAL(SIG_OVERFLOW1) //4.096 Mc = 65536*0.0625us - время переполнения таймера
{
 cba:	1f 92       	push	r1
 cbc:	0f 92       	push	r0
 cbe:	0f b6       	in	r0, 0x3f	; 63
 cc0:	0f 92       	push	r0
 cc2:	11 24       	eor	r1, r1
 cc4:	8f 93       	push	r24
 cc6:	9f 93       	push	r25
 cc8:	af 93       	push	r26
 cca:	bf 93       	push	r27
 ccc:	ef 93       	push	r30
 cce:	ff 93       	push	r31
 cd0:	df 93       	push	r29
 cd2:	cf 93       	push	r28
 cd4:	cd b7       	in	r28, 0x3d	; 61
 cd6:	de b7       	in	r29, 0x3e	; 62
  if (CtOverLow) CtOverLow--;  //16 переполнений до установки флага переполнения NDiz_Overflow)
 cd8:	80 91 7f 00 	lds	r24, 0x007F
 cdc:	88 23       	and	r24, r24
 cde:	31 f0       	breq	.+12     	; 0xcec <__vector_8+0x32>
 ce0:	80 91 7f 00 	lds	r24, 0x007F
 ce4:	81 50       	subi	r24, 0x01	; 1
 ce6:	80 93 7f 00 	sts	0x007F, r24
 cea:	03 c0       	rjmp	.+6      	; 0xcf2 <__vector_8+0x38>
  else           NDiz_Overflow=1;
 cec:	81 e0       	ldi	r24, 0x01	; 1
 cee:	80 93 72 00 	sts	0x0072, r24

  if(timer_250 == 0)           //если прошло 250 мс без изменения индикации 
 cf2:	80 91 ba 00 	lds	r24, 0x00BA
 cf6:	88 23       	and	r24, r24
 cf8:	b1 f4       	brne	.+44     	; 0xd26 <__vector_8+0x6c>
  {
    timer_250 = RELOAD;        //начать новый цикл с периодом 250 мс
 cfa:	8e e3       	ldi	r24, 0x3E	; 62
 cfc:	80 93 ba 00 	sts	0x00BA, r24
    PORTC ^= mask_leds_c;      //инвертировать сигнал, управляющий индикацией
 d00:	a5 e3       	ldi	r26, 0x35	; 53
 d02:	b0 e0       	ldi	r27, 0x00	; 0
 d04:	e5 e3       	ldi	r30, 0x35	; 53
 d06:	f0 e0       	ldi	r31, 0x00	; 0
 d08:	90 81       	ld	r25, Z
 d0a:	80 91 b5 00 	lds	r24, 0x00B5
 d0e:	89 27       	eor	r24, r25
 d10:	8c 93       	st	X, r24
    PORTD ^= mask_leds_d;
 d12:	a2 e3       	ldi	r26, 0x32	; 50
 d14:	b0 e0       	ldi	r27, 0x00	; 0
 d16:	e2 e3       	ldi	r30, 0x32	; 50
 d18:	f0 e0       	ldi	r31, 0x00	; 0
 d1a:	90 81       	ld	r25, Z
 d1c:	80 91 74 00 	lds	r24, 0x0074
 d20:	89 27       	eor	r24, r25
 d22:	8c 93       	st	X, r24
 d24:	05 c0       	rjmp	.+10     	; 0xd30 <__vector_8+0x76>
  }
  else timer_250--;
 d26:	80 91 ba 00 	lds	r24, 0x00BA
 d2a:	81 50       	subi	r24, 0x01	; 1
 d2c:	80 93 ba 00 	sts	0x00BA, r24

  //сканирование кнопок
  if(Key_Inp == KEY_EMPTY)
 d30:	80 91 8a 00 	lds	r24, 0x008A
 d34:	88 23       	and	r24, r24
 d36:	09 f0       	breq	.+2      	; 0xd3a <__vector_8+0x80>
 d38:	50 c0       	rjmp	.+160    	; 0xdda <__vector_8+0x120>
  {
    if((INKEY_PORT & KEY_MASK) != KEY_MASK)
 d3a:	e6 e3       	ldi	r30, 0x36	; 54
 d3c:	f0 e0       	ldi	r31, 0x00	; 0
 d3e:	80 81       	ld	r24, Z
 d40:	88 2f       	mov	r24, r24
 d42:	90 e0       	ldi	r25, 0x00	; 0
 d44:	8c 70       	andi	r24, 0x0C	; 12
 d46:	90 70       	andi	r25, 0x00	; 0
 d48:	8c 30       	cpi	r24, 0x0C	; 12
 d4a:	91 05       	cpc	r25, r1
 d4c:	31 f0       	breq	.+12     	; 0xd5a <__vector_8+0xa0>
        Key_new = INKEY_PORT & KEY_MASK;
 d4e:	e6 e3       	ldi	r30, 0x36	; 54
 d50:	f0 e0       	ldi	r31, 0x00	; 0
 d52:	80 81       	ld	r24, Z
 d54:	8c 70       	andi	r24, 0x0C	; 12
 d56:	80 93 ae 00 	sts	0x00AE, r24
    if (Key_new != 0xff)
 d5a:	80 91 ae 00 	lds	r24, 0x00AE
 d5e:	8f 3f       	cpi	r24, 0xFF	; 255
 d60:	21 f1       	breq	.+72     	; 0xdaa <__vector_8+0xf0>
    {
      if(Key_new == Key_old)
 d62:	90 91 ae 00 	lds	r25, 0x00AE
 d66:	80 91 ac 00 	lds	r24, 0x00AC
 d6a:	98 17       	cp	r25, r24
 d6c:	71 f4       	brne	.+28     	; 0xd8a <__vector_8+0xd0>
      {
        if(Count_on > KSTATE) Ff_key = 1;
 d6e:	80 91 b6 00 	lds	r24, 0x00B6
 d72:	8b 30       	cpi	r24, 0x0B	; 11
 d74:	20 f0       	brcs	.+8      	; 0xd7e <__vector_8+0xc4>
 d76:	81 e0       	ldi	r24, 0x01	; 1
 d78:	80 93 88 00 	sts	0x0088, r24
 d7c:	12 c0       	rjmp	.+36     	; 0xda2 <__vector_8+0xe8>
        else Count_on++;
 d7e:	80 91 b6 00 	lds	r24, 0x00B6
 d82:	8f 5f       	subi	r24, 0xFF	; 255
 d84:	80 93 b6 00 	sts	0x00B6, r24
 d88:	0c c0       	rjmp	.+24     	; 0xda2 <__vector_8+0xe8>
      }
      else
      {
        Key_old = Key_new;
 d8a:	80 91 ae 00 	lds	r24, 0x00AE
 d8e:	80 93 ac 00 	sts	0x00AC, r24
        Count_on = Count_off = 0;
 d92:	10 92 75 00 	sts	0x0075, r1
 d96:	80 91 75 00 	lds	r24, 0x0075
 d9a:	80 93 b6 00 	sts	0x00B6, r24
        Ff_key = 0;
 d9e:	10 92 88 00 	sts	0x0088, r1
      }
      Key_new = 0xff;
 da2:	8f ef       	ldi	r24, 0xFF	; 255
 da4:	80 93 ae 00 	sts	0x00AE, r24
 da8:	18 c0       	rjmp	.+48     	; 0xdda <__vector_8+0x120>
    }
    else
    {
      if(Ff_key == 1)
 daa:	80 91 88 00 	lds	r24, 0x0088
 dae:	81 30       	cpi	r24, 0x01	; 1
 db0:	89 f4       	brne	.+34     	; 0xdd4 <__vector_8+0x11a>
      {
        if(Count_off > KSTATE)
 db2:	80 91 75 00 	lds	r24, 0x0075
 db6:	8b 30       	cpi	r24, 0x0B	; 11
 db8:	38 f0       	brcs	.+14     	; 0xdc8 <__vector_8+0x10e>
        {
          Ff_key = 0;
 dba:	10 92 88 00 	sts	0x0088, r1
          Key_Inp = Key_old;
 dbe:	80 91 ac 00 	lds	r24, 0x00AC
 dc2:	80 93 8a 00 	sts	0x008A, r24
 dc6:	09 c0       	rjmp	.+18     	; 0xdda <__vector_8+0x120>
        }
        else Count_off++;
 dc8:	80 91 75 00 	lds	r24, 0x0075
 dcc:	8f 5f       	subi	r24, 0xFF	; 255
 dce:	80 93 75 00 	sts	0x0075, r24
 dd2:	03 c0       	rjmp	.+6      	; 0xdda <__vector_8+0x120>
      }
      else Key_old = 0x55;
 dd4:	85 e5       	ldi	r24, 0x55	; 85
 dd6:	80 93 ac 00 	sts	0x00AC, r24
    }
  }
}
 dda:	cf 91       	pop	r28
 ddc:	df 91       	pop	r29
 dde:	ff 91       	pop	r31
 de0:	ef 91       	pop	r30
 de2:	bf 91       	pop	r27
 de4:	af 91       	pop	r26
 de6:	9f 91       	pop	r25
 de8:	8f 91       	pop	r24
 dea:	0f 90       	pop	r0
 dec:	0f be       	out	0x3f, r0	; 63
 dee:	0f 90       	pop	r0
 df0:	1f 90       	pop	r1
 df2:	18 95       	reti

00000df4 <__vector_14>:

SIGNAL(SIG_ADC)
{
 df4:	1f 92       	push	r1
 df6:	0f 92       	push	r0
 df8:	0f b6       	in	r0, 0x3f	; 63
 dfa:	0f 92       	push	r0
 dfc:	11 24       	eor	r1, r1
 dfe:	2f 93       	push	r18
 e00:	3f 93       	push	r19
 e02:	4f 93       	push	r20
 e04:	5f 93       	push	r21
 e06:	8f 93       	push	r24
 e08:	9f 93       	push	r25
 e0a:	af 93       	push	r26
 e0c:	bf 93       	push	r27
 e0e:	ef 93       	push	r30
 e10:	ff 93       	push	r31
 e12:	df 93       	push	r29
 e14:	cf 93       	push	r28
 e16:	00 d0       	rcall	.+0      	; 0xe18 <__vector_14+0x24>
 e18:	cd b7       	in	r28, 0x3d	; 61
 e1a:	de b7       	in	r29, 0x3e	; 62
  unsigned int RegInt0;
  RegInt0=ADC;
 e1c:	e4 e2       	ldi	r30, 0x24	; 36
 e1e:	f0 e0       	ldi	r31, 0x00	; 0
 e20:	80 81       	ld	r24, Z
 e22:	91 81       	ldd	r25, Z+1	; 0x01
 e24:	9a 83       	std	Y+2, r25	; 0x02
 e26:	89 83       	std	Y+1, r24	; 0x01

  if (CtAd)
 e28:	80 91 d4 00 	lds	r24, 0x00D4
 e2c:	88 23       	and	r24, r24
 e2e:	b9 f0       	breq	.+46     	; 0xe5e <__vector_14+0x6a>
  {
    --CtAd; //64 измерения
 e30:	80 91 d4 00 	lds	r24, 0x00D4
 e34:	81 50       	subi	r24, 0x01	; 1
 e36:	80 93 d4 00 	sts	0x00D4, r24
    if (CtAd<=CtAd0)
 e3a:	80 91 d4 00 	lds	r24, 0x00D4
 e3e:	80 34       	cpi	r24, 0x40	; 64
 e40:	08 f0       	brcs	.+2      	; 0xe44 <__vector_14+0x50>
 e42:	4e c0       	rjmp	.+156    	; 0xee0 <__vector_14+0xec>
    {
      AdTemp +=RegInt0;
 e44:	80 91 77 00 	lds	r24, 0x0077
 e48:	90 91 78 00 	lds	r25, 0x0078
 e4c:	29 81       	ldd	r18, Y+1	; 0x01
 e4e:	3a 81       	ldd	r19, Y+2	; 0x02
 e50:	82 0f       	add	r24, r18
 e52:	93 1f       	adc	r25, r19
 e54:	90 93 78 00 	sts	0x0078, r25
 e58:	80 93 77 00 	sts	0x0077, r24
 e5c:	41 c0       	rjmp	.+130    	; 0xee0 <__vector_14+0xec>
    }
  }
  else
  {
    AdResult[NumberAd]=AdTemp;
 e5e:	80 91 80 00 	lds	r24, 0x0080
 e62:	88 2f       	mov	r24, r24
 e64:	90 e0       	ldi	r25, 0x00	; 0
 e66:	20 91 77 00 	lds	r18, 0x0077
 e6a:	30 91 78 00 	lds	r19, 0x0078
 e6e:	88 0f       	add	r24, r24
 e70:	99 1f       	adc	r25, r25
 e72:	fc 01       	movw	r30, r24
 e74:	eb 51       	subi	r30, 0x1B	; 27
 e76:	ff 4f       	sbci	r31, 0xFF	; 255
 e78:	31 83       	std	Z+1, r19	; 0x01
 e7a:	20 83       	st	Z, r18
    AdResult[NumberAd]>>=6;
 e7c:	80 91 80 00 	lds	r24, 0x0080
 e80:	48 2f       	mov	r20, r24
 e82:	50 e0       	ldi	r21, 0x00	; 0
 e84:	80 91 80 00 	lds	r24, 0x0080
 e88:	88 2f       	mov	r24, r24
 e8a:	90 e0       	ldi	r25, 0x00	; 0
 e8c:	88 0f       	add	r24, r24
 e8e:	99 1f       	adc	r25, r25
 e90:	fc 01       	movw	r30, r24
 e92:	eb 51       	subi	r30, 0x1B	; 27
 e94:	ff 4f       	sbci	r31, 0xFF	; 255
 e96:	80 81       	ld	r24, Z
 e98:	91 81       	ldd	r25, Z+1	; 0x01
 e9a:	9c 01       	movw	r18, r24
 e9c:	00 24       	eor	r0, r0
 e9e:	22 0f       	add	r18, r18
 ea0:	33 1f       	adc	r19, r19
 ea2:	00 1c       	adc	r0, r0
 ea4:	22 0f       	add	r18, r18
 ea6:	33 1f       	adc	r19, r19
 ea8:	00 1c       	adc	r0, r0
 eaa:	23 2f       	mov	r18, r19
 eac:	30 2d       	mov	r19, r0
 eae:	ca 01       	movw	r24, r20
 eb0:	88 0f       	add	r24, r24
 eb2:	99 1f       	adc	r25, r25
 eb4:	fc 01       	movw	r30, r24
 eb6:	eb 51       	subi	r30, 0x1B	; 27
 eb8:	ff 4f       	sbci	r31, 0xFF	; 255
 eba:	31 83       	std	Z+1, r19	; 0x01
 ebc:	20 83       	st	Z, r18
    AdTemp=0;
 ebe:	10 92 78 00 	sts	0x0078, r1
 ec2:	10 92 77 00 	sts	0x0077, r1
    CtAd=CtAd0+2;
 ec6:	81 e4       	ldi	r24, 0x41	; 65
 ec8:	80 93 d4 00 	sts	0x00D4, r24
    //if(NumberAd==11)
    NumberAd=NumberAdNew[NumberAd];
 ecc:	80 91 80 00 	lds	r24, 0x0080
 ed0:	88 2f       	mov	r24, r24
 ed2:	90 e0       	ldi	r25, 0x00	; 0
 ed4:	fc 01       	movw	r30, r24
 ed6:	e0 5a       	subi	r30, 0xA0	; 160
 ed8:	ff 4f       	sbci	r31, 0xFF	; 255
 eda:	80 81       	ld	r24, Z
 edc:	80 93 80 00 	sts	0x0080, r24
  }

  RegInt0=ADMUX;
 ee0:	e7 e2       	ldi	r30, 0x27	; 39
 ee2:	f0 e0       	ldi	r31, 0x00	; 0
 ee4:	80 81       	ld	r24, Z
 ee6:	88 2f       	mov	r24, r24
 ee8:	90 e0       	ldi	r25, 0x00	; 0
 eea:	9a 83       	std	Y+2, r25	; 0x02
 eec:	89 83       	std	Y+1, r24	; 0x01
  RegInt0 &=0xe0;     //обнуление MUX4..0
 eee:	89 81       	ldd	r24, Y+1	; 0x01
 ef0:	9a 81       	ldd	r25, Y+2	; 0x02
 ef2:	80 7e       	andi	r24, 0xE0	; 224
 ef4:	90 70       	andi	r25, 0x00	; 0
 ef6:	9a 83       	std	Y+2, r25	; 0x02
 ef8:	89 83       	std	Y+1, r24	; 0x01
  RegInt0 |=NumberAd; //выставление нового адреса канала ацп
 efa:	80 91 80 00 	lds	r24, 0x0080
 efe:	28 2f       	mov	r18, r24
 f00:	30 e0       	ldi	r19, 0x00	; 0
 f02:	89 81       	ldd	r24, Y+1	; 0x01
 f04:	9a 81       	ldd	r25, Y+2	; 0x02
 f06:	82 2b       	or	r24, r18
 f08:	93 2b       	or	r25, r19
 f0a:	9a 83       	std	Y+2, r25	; 0x02
 f0c:	89 83       	std	Y+1, r24	; 0x01
  ADMUX=RegInt0;
 f0e:	e7 e2       	ldi	r30, 0x27	; 39
 f10:	f0 e0       	ldi	r31, 0x00	; 0
 f12:	89 81       	ldd	r24, Y+1	; 0x01
 f14:	80 83       	st	Z, r24

  ADCSRA |=(1<<ADSC); //start conversion
 f16:	a6 e2       	ldi	r26, 0x26	; 38
 f18:	b0 e0       	ldi	r27, 0x00	; 0
 f1a:	e6 e2       	ldi	r30, 0x26	; 38
 f1c:	f0 e0       	ldi	r31, 0x00	; 0
 f1e:	80 81       	ld	r24, Z
 f20:	80 64       	ori	r24, 0x40	; 64
 f22:	8c 93       	st	X, r24
}
 f24:	0f 90       	pop	r0
 f26:	0f 90       	pop	r0
 f28:	cf 91       	pop	r28
 f2a:	df 91       	pop	r29
 f2c:	ff 91       	pop	r31
 f2e:	ef 91       	pop	r30
 f30:	bf 91       	pop	r27
 f32:	af 91       	pop	r26
 f34:	9f 91       	pop	r25
 f36:	8f 91       	pop	r24
 f38:	5f 91       	pop	r21
 f3a:	4f 91       	pop	r20
 f3c:	3f 91       	pop	r19
 f3e:	2f 91       	pop	r18
 f40:	0f 90       	pop	r0
 f42:	0f be       	out	0x3f, r0	; 63
 f44:	0f 90       	pop	r0
 f46:	1f 90       	pop	r1
 f48:	18 95       	reti

00000f4a <__udivmodsi4>:
 f4a:	a1 e2       	ldi	r26, 0x21	; 33
 f4c:	1a 2e       	mov	r1, r26
 f4e:	aa 1b       	sub	r26, r26
 f50:	bb 1b       	sub	r27, r27
 f52:	fd 01       	movw	r30, r26
 f54:	0d c0       	rjmp	.+26     	; 0xf70 <__udivmodsi4_ep>

00000f56 <__udivmodsi4_loop>:
 f56:	aa 1f       	adc	r26, r26
 f58:	bb 1f       	adc	r27, r27
 f5a:	ee 1f       	adc	r30, r30
 f5c:	ff 1f       	adc	r31, r31
 f5e:	a2 17       	cp	r26, r18
 f60:	b3 07       	cpc	r27, r19
 f62:	e4 07       	cpc	r30, r20
 f64:	f5 07       	cpc	r31, r21
 f66:	20 f0       	brcs	.+8      	; 0xf70 <__udivmodsi4_ep>
 f68:	a2 1b       	sub	r26, r18
 f6a:	b3 0b       	sbc	r27, r19
 f6c:	e4 0b       	sbc	r30, r20
 f6e:	f5 0b       	sbc	r31, r21

00000f70 <__udivmodsi4_ep>:
 f70:	66 1f       	adc	r22, r22
 f72:	77 1f       	adc	r23, r23
 f74:	88 1f       	adc	r24, r24
 f76:	99 1f       	adc	r25, r25
 f78:	1a 94       	dec	r1
 f7a:	69 f7       	brne	.-38     	; 0xf56 <__udivmodsi4_loop>
 f7c:	60 95       	com	r22
 f7e:	70 95       	com	r23
 f80:	80 95       	com	r24
 f82:	90 95       	com	r25
 f84:	9b 01       	movw	r18, r22
 f86:	ac 01       	movw	r20, r24
 f88:	bd 01       	movw	r22, r26
 f8a:	cf 01       	movw	r24, r30
 f8c:	08 95       	ret

00000f8e <__eerd_word_m8535>:
 f8e:	a8 e1       	ldi	r26, 0x18	; 24
 f90:	b0 e0       	ldi	r27, 0x00	; 0
 f92:	42 e0       	ldi	r20, 0x02	; 2
 f94:	50 e0       	ldi	r21, 0x00	; 0
 f96:	06 c0       	rjmp	.+12     	; 0xfa4 <__eerd_blraw_m8535>

00000f98 <__eeupd_word_m8535>:
 f98:	01 96       	adiw	r24, 0x01	; 1
 f9a:	27 2f       	mov	r18, r23
 f9c:	12 d0       	rcall	.+36     	; 0xfc2 <__eeupd_r18_m8535>
 f9e:	10 c0       	rjmp	.+32     	; 0xfc0 <__eeupd_byte_m8535>

00000fa0 <__eerd_block_m8535>:
 fa0:	dc 01       	movw	r26, r24
 fa2:	cb 01       	movw	r24, r22

00000fa4 <__eerd_blraw_m8535>:
 fa4:	fc 01       	movw	r30, r24
 fa6:	e1 99       	sbic	0x1c, 1	; 28
 fa8:	fe cf       	rjmp	.-4      	; 0xfa6 <__eerd_blraw_m8535+0x2>
 faa:	06 c0       	rjmp	.+12     	; 0xfb8 <__eerd_blraw_m8535+0x14>
 fac:	ff bb       	out	0x1f, r31	; 31
 fae:	ee bb       	out	0x1e, r30	; 30
 fb0:	e0 9a       	sbi	0x1c, 0	; 28
 fb2:	31 96       	adiw	r30, 0x01	; 1
 fb4:	0d b2       	in	r0, 0x1d	; 29
 fb6:	0d 92       	st	X+, r0
 fb8:	41 50       	subi	r20, 0x01	; 1
 fba:	50 40       	sbci	r21, 0x00	; 0
 fbc:	b8 f7       	brcc	.-18     	; 0xfac <__eerd_blraw_m8535+0x8>
 fbe:	08 95       	ret

00000fc0 <__eeupd_byte_m8535>:
 fc0:	26 2f       	mov	r18, r22

00000fc2 <__eeupd_r18_m8535>:
 fc2:	e1 99       	sbic	0x1c, 1	; 28
 fc4:	fe cf       	rjmp	.-4      	; 0xfc2 <__eeupd_r18_m8535>
 fc6:	9f bb       	out	0x1f, r25	; 31
 fc8:	8e bb       	out	0x1e, r24	; 30
 fca:	e0 9a       	sbi	0x1c, 0	; 28
 fcc:	01 97       	sbiw	r24, 0x01	; 1
 fce:	0d b2       	in	r0, 0x1d	; 29
 fd0:	02 16       	cp	r0, r18
 fd2:	31 f0       	breq	.+12     	; 0xfe0 <__eeupd_r18_m8535+0x1e>
 fd4:	2d bb       	out	0x1d, r18	; 29
 fd6:	0f b6       	in	r0, 0x3f	; 63
 fd8:	f8 94       	cli
 fda:	e2 9a       	sbi	0x1c, 2	; 28
 fdc:	e1 9a       	sbi	0x1c, 1	; 28
 fde:	0f be       	out	0x3f, r0	; 63
 fe0:	08 95       	ret

00000fe2 <_exit>:
 fe2:	f8 94       	cli

00000fe4 <__stop_program>:
 fe4:	ff cf       	rjmp	.-2      	; 0xfe4 <__stop_program>
